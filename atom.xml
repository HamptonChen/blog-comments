<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码视界</title>
  
  <subtitle>Hampton Chen&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenhanpeng.com/"/>
  <updated>2019-09-22T13:36:16.030Z</updated>
  <id>http://www.chenhanpeng.com/</id>
  
  <author>
    <name>Hampton Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python从小白到攻城狮(10)——高阶函数</title>
    <link href="http://www.chenhanpeng.com/2019/09/22/python_series/python_10_%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>http://www.chenhanpeng.com/2019/09/22/python_series/python_10_高阶函数/</id>
    <published>2019-09-22T13:28:53.000Z</published>
    <updated>2019-09-22T13:36:16.030Z</updated>
    
    <content type="html"><![CDATA[<p>本节将主要介绍什么是高阶函数、高阶函数的用法以及Python的几个常见的内置高阶函数。</p><h1 id="什么是高阶函数"><a href="#什么是高阶函数" class="headerlink" title="什么是高阶函数"></a>什么是高阶函数</h1><p>高阶函数(Higher-order function)：一个函数可以作为参数传给另一个函数，或者一个函数的返回值为另一个函数（若返回值为该函数本身，则为递归），满足其一则为高阶函数。</p><p>下面，我们通过例子来进一步学习高阶函数的用法。</p><p><strong>参数为函数</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数为函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_function</span><span class="params">(func)</span>:</span></span><br><span class="line">    func()</span><br><span class="line">    print(<span class="string">'in the print_function'</span>)</span><br><span class="line"></span><br><span class="line">print_function(print_hello)</span><br><span class="line"></span><br><span class="line"><span class="comment">########输出结果######</span></span><br><span class="line">hello world</span><br><span class="line"><span class="keyword">in</span> the print_function</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，我们将<code>print_hello()</code>函数作为参数func传递给print_function()函数，直接调用print_hello()和调用func()结果一样。</p><p><strong>返回值为函数</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回值为函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in the print_func'</span>)</span><br><span class="line">    <span class="keyword">return</span> print_hello</span><br><span class="line"></span><br><span class="line">result = print_function()</span><br><span class="line">result()</span><br><span class="line"></span><br><span class="line"><span class="comment">#####输出#####</span></span><br><span class="line"><span class="keyword">in</span> the print_func</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>上面的例子中，print_hello()函数作为print_function()的返回值。</p><blockquote><p>备注：函数名(print_hello、print_function)–&gt;其为该函数的内存地址；函数名+括号(print_hello())–&gt;调用该函数。</p></blockquote><h1 id="Python内置的高阶函数"><a href="#Python内置的高阶函数" class="headerlink" title="Python内置的高阶函数"></a>Python内置的高阶函数</h1><p>map()、filter()、reduce()、sorted()，这几个均为Python内置的高阶函数。通常结合匿名函数lambda一起使用。接下来我们看一下这三个函数的用法以及其内部原理。</p><h2 id="map-function-iterable-函数："><a href="#map-function-iterable-函数：" class="headerlink" title="map(function, iterable)函数："></a>map(function, iterable)函数：</h2><p>map函数接收的是两个参数：一个函数，一个Iterable。map对iterable中的每个元素，都运用function这个函数，最后返回一个新的Iterable，即迭代器对象，例如：<code>&lt;map object at 0x00000214EEF40BA8&gt;</code>。</p><p>比如：要对列表中的每个元素乘以2，用map可以实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">re = map(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, l)</span><br><span class="line">print(list(re))  <span class="comment"># [2， 4， 6， 8， 10]</span></span><br></pre></td></tr></table></figure></p><h2 id="filter-function-iterable-函数"><a href="#filter-function-iterable-函数" class="headerlink" title="filter(function, iterable)函数"></a>filter(function, iterable)函数</h2><p>filter函数和map函数类似，也是接收一个函数和一个序列的高阶函数，主要功能是过滤。</p><p>filter()函数表示对iterable中的每个元素，都是用function判断，并返回True或False，最后将返回True的元素组成一个迭代器对象，其返回值也是迭代器对象，例如：<code>&lt;filter object at 0x000002042D25EA90&gt;</code>。</p><p>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</p><p>比如：我们要返回一个列表中的所有奇数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">result = filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span>, l)</span><br><span class="line">print(list(result))  <span class="comment">#[1, 3, 5]</span></span><br></pre></td></tr></table></figure></p><h2 id="reduce-function-iterable-函数"><a href="#reduce-function-iterable-函数" class="headerlink" title="reduce(function, iterable)函数"></a>reduce(function, iterable)函数</h2><p>这里的function同样是一个函数对象，规定它有两个参数，表示对iterable中的每个元素及上一次调用的结果，运用function进行计算，所以最后返回的是一个单独的数值。</p><p>例子：计算某个列表元素的乘积。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">l2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y: x * y, l2)</span><br><span class="line">print(result)  <span class="comment"># 1*2*3*4*5=120</span></span><br></pre></td></tr></table></figure></p><blockquote><p>python3中reduce函数被取消了，放入到了functools模块中，所以在语句前加上一条：<code>from functools import reduce</code></p></blockquote><h2 id="sorted-函数"><a href="#sorted-函数" class="headerlink" title="sorted()函数"></a>sorted()函数</h2><p>sorted() 函数对所有可迭代的对象进行排序操作。</p><p><strong>sort 与 sorted 区别</strong>：</p><ul><li>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</li><li>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</li></ul><p><strong>sorted语法</strong>：<br>sorted(iterable, key=None, reverse=False)  </p><p><strong>参数说明</strong>：</p><ul><li>iterable：可迭代对象</li><li>key：主要用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse：排序规则，reverse=True 降序，reverse=False 升序（默认）。</li></ul><p><strong>返回值</strong><br>返回重新排序的列表</p><p><strong>示例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>]</span><br><span class="line">b = sorted(a)</span><br><span class="line">print(a) <span class="comment"># [1, 5, 3, 6, 9, 8]</span></span><br><span class="line">print(b)   <span class="comment"># [1, 3, 5, 6, 8, 9]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = [(<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">3</span>), (<span class="string">'d'</span>, <span class="number">4</span>)]</span><br><span class="line">l1 = sorted(l, key=<span class="keyword">lambda</span> s:s[<span class="number">1</span>])</span><br><span class="line">print(l1)   <span class="comment"># [('a', 1), ('b', 2), ('c', 3), ('d', 4)]</span></span><br><span class="line">l2 = sorted(l, key=<span class="keyword">lambda</span> s:s[<span class="number">1</span>], reverse=<span class="literal">True</span>) <span class="comment"># 降序</span></span><br><span class="line">print(l2)   <span class="comment"># [('d', 4), ('c', 3), ('b', 2), ('a', 1)]</span></span><br></pre></td></tr></table></figure></p><p><strong>文中示例代码</strong>： <a href="https://github.com/HamptonChen/python-learning" target="_blank" rel="noopener">python-learning</a></p><p>未完待续，持续更新中……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本节将主要介绍什么是高阶函数、高阶函数的用法以及Python的几个常见的内置高阶函数。&lt;/p&gt;
&lt;h1 id=&quot;什么是高阶函数&quot;&gt;&lt;a href=&quot;#什么是高阶函数&quot; class=&quot;headerlink&quot; title=&quot;什么是高阶函数&quot;&gt;&lt;/a&gt;什么是高阶函数&lt;/h1&gt;&lt;p
      
    
    </summary>
    
      <category term="Python" scheme="http://www.chenhanpeng.com/categories/Python/"/>
    
    
      <category term="python教程" scheme="http://www.chenhanpeng.com/tags/python%E6%95%99%E7%A8%8B/"/>
    
      <category term="高阶函数" scheme="http://www.chenhanpeng.com/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python从小白到攻城狮(9)——匿名函数</title>
    <link href="http://www.chenhanpeng.com/2019/09/18/python_series/python_9_%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://www.chenhanpeng.com/2019/09/18/python_series/python_9_匿名函数/</id>
    <published>2019-09-18T04:00:13.000Z</published>
    <updated>2019-09-18T12:21:38.238Z</updated>
    
    <content type="html"><![CDATA[<p>在前面函数那节中，我们一起学习了Python的常规函数。但是在代码中，除了常规函数，我们也会见到一些“非常规”函数，它们往往很简短，就一行，并且有个很酷炫的名字——<code>lambda</code>，这就是匿名函数。</p><h1 id="什么是匿名函数"><a href="#什么是匿名函数" class="headerlink" title="什么是匿名函数"></a>什么是匿名函数</h1><p>所谓匿名，即不再使用def语句这样标准的形式定义一个函数。</p><ul><li>lambda只是一个表达式，函数体比def简单得多。</li><li>lambda的主题是一个表达式，而不是一个代码块，仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只有一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>lambda函数的语法只包含一个语句，如下：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">lambda</span></span> argument1, argument2,... argumentN : expression</span><br></pre></td></tr></table></figure></p><p>从上面的语法我们可以看到，匿名函数的关键字是lambda，之后是一系列的参数，用冒号隔开，最后则是由这些参数组成的表达式。</p><p>我们通过几个例子来看下它的用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">square = <span class="keyword">lambda</span> x: x**<span class="number">2</span></span><br><span class="line">print(square(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">sum = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">print(sum(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure></p><p>可以看到，匿名函数lambda和常规函数一样，返回的都是一个函数对象(function object)，它们的用法也极其相似，不过有下面几点区别：</p><h1 id="匿名函数和常规函数区别"><a href="#匿名函数和常规函数区别" class="headerlink" title="匿名函数和常规函数区别"></a>匿名函数和常规函数区别</h1><h2 id="第一，lambda是一个表达式-expression-，而不是一个语句-statement-。"><a href="#第一，lambda是一个表达式-expression-，而不是一个语句-statement-。" class="headerlink" title="第一，lambda是一个表达式(expression)，而不是一个语句(statement)。"></a>第一，lambda是一个表达式(expression)，而不是一个语句(statement)。</h2><ul><li>所谓的表达式，就是用一系列“公式”去表达一个东西，比如 x+y 、 x**2等等。</li><li>所谓的语句，则一定是完成了某些功能，比如赋值语句 x = 2完成了赋值，print语句print(x) 完成了打印等等。</li></ul><p>因此，lambda可以用在一些常规函数def不能用的地方，比如，lambda可以用在列表内部，而常规函数却不能：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [(<span class="keyword">lambda</span> x: x*x)(x) <span class="keyword">for</span> <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure></p><p>再比如，lambda可以被用作某些函数的参数，而常规函数def也不能：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [(<span class="number">1</span>, <span class="number">20</span>), (<span class="number">3</span>, <span class="number">10</span>), (<span class="number">5</span>, <span class="number">25</span>), (<span class="number">2</span>, <span class="number">0</span>)]</span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment"># 按照列表中元组的第二个元素排序</span></span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure></p><p>常规函数def必须通过其函数名被调用，因此必须首先被定义。但是作为一个表达式的lambda，返回的函数对象就不需要名字了。</p><h2 id="第二，lambda的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块。"><a href="#第二，lambda的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块。" class="headerlink" title="第二，lambda的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块。"></a>第二，lambda的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块。</h2><p>这其实是出于设计的考虑。Python之所以发明lambda，就是为了让它和常规函数各司其职：lambda专注于简单的任务，而常规函数则负责更复杂的多行逻辑。</p><p>用匿名函数改造下面的代码：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">L = <span class="keyword">list</span>(<span class="built_in">filter</span>(is_odd, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"># lambda改造</span><br><span class="line">new_l = <span class="keyword">list</span>(<span class="built_in">filter</span>(lambda <span class="keyword">x</span>: <span class="keyword">x</span> % <span class="number">2</span> == <span class="number">1</span>, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)))</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一节，我们一起学习了Python中的匿名函数lambda，它的主要用途是减少代码的复杂度。需要注意的是lambda是一个表达式，并不是一个语句；它只能写成一行的表达形式，语法上并不支持多行。匿名函数通常的使用场景是：程序中需要使用一个函数完成一个简单的功能，并且该函数只调用一次。</p><p><strong>文中示例代码</strong>： <a href="https://github.com/HamptonChen/python-learning" target="_blank" rel="noopener">python-learning</a></p><p>未完待续，持续更新中……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前面函数那节中，我们一起学习了Python的常规函数。但是在代码中，除了常规函数，我们也会见到一些“非常规”函数，它们往往很简短，就一行，并且有个很酷炫的名字——&lt;code&gt;lambda&lt;/code&gt;，这就是匿名函数。&lt;/p&gt;
&lt;h1 id=&quot;什么是匿名函数&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Python" scheme="http://www.chenhanpeng.com/categories/Python/"/>
    
    
      <category term="python教程" scheme="http://www.chenhanpeng.com/tags/python%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python从小白到攻城狮(8)——模块</title>
    <link href="http://www.chenhanpeng.com/2019/09/05/python_series/python_8_%E6%A8%A1%E5%9D%97/"/>
    <id>http://www.chenhanpeng.com/2019/09/05/python_series/python_8_模块/</id>
    <published>2019-09-05T15:00:13.000Z</published>
    <updated>2019-09-18T12:21:01.200Z</updated>
    
    <content type="html"><![CDATA[<p>随着程序代码越写越多，一个文件中的代码越来越长，也越来越难以维护。为了编写可维护的代码，我们把很多函数分组，放到不同的文件中，这样每个文件包含的代码相对较少。</p><p>在Python中，一个.py文件就称为一个模块(Module)，里面定义了一些函数、类和变量，也可能包含可执行的代码。</p><p>模块让你能够有逻辑地组织你的 Python 代码段。把相关的代码分配到一个模块里能让你的代码更好用，更易懂。</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><hr><p>从上面我们知道了模块就是一个.py文件，接下来我们来看下如何定义和引用一个模块。</p><h2 id="如何定义一个模块"><a href="#如何定义一个模块" class="headerlink" title="如何定义一个模块"></a>如何定义一个模块</h2><p>下面是简单的模块hello.py:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello world!'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h2><p>定义好模块后，我们可以使用import语句来引入模块，语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1[, module2[,... moduleN]]</span><br></pre></td></tr></table></figure></p><p>当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。</p><p>调用的时候使用<strong>函数名.方法名</strong>来进行调用。</p><p>我们新建一个test_hello.py文件来调用hello.py模块的方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hello</span><br><span class="line"></span><br><span class="line">hello.print_hello()</span><br></pre></td></tr></table></figure></p><p>不管你执行多少次import，一个模块只会被导入一次。这样可以防止导入模块被一遍又一遍地执行。</p><h2 id="from…import语句"><a href="#from…import语句" class="headerlink" title="from…import语句"></a>from…import语句</h2><p>Python的from语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="keyword">module</span> <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure></p><p>例如，我们要导入hello.py模块中的print_hello方法，使用如下语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> print_hello</span><br></pre></td></tr></table></figure></p><p>这个声明不会把整个 hello 模块导入到当前的命名空间中，它只会将 hello 里的 print_hello 单个引入到执行这个声明的模块的全局符号表。</p><h2 id="from…import-语句"><a href="#from…import-语句" class="headerlink" title="from…import* 语句"></a>from…import* 语句</h2><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></p><blockquote><p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p></blockquote><h1 id="Python中的包"><a href="#Python中的包" class="headerlink" title="Python中的包"></a>Python中的包</h1><hr><p>包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的Python的应用环境。</p><p>简单来说，包就是文件夹，但该文件夹下必须存在<strong>init</strong>.py文件，该文件的内容可以为空。<strong>init</strong>.py用于标识当前文件夹是一个包。</p><p>示例：<br>我们创建一个test包，目录结构如下：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line"> -- __init__.py</span><br><span class="line"> -- test_cal.py</span><br></pre></td></tr></table></figure></p><p>test_cal.py模块的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure></p><h2 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h2><p>Python包的使用和模块的使用类似，可以通过import语句和from…import语句导入。</p><p>新建一个do.py来导入和使用test包，我们先用import语句导入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test.test_cal</span><br><span class="line">print(test.test_cal.add(<span class="number">10</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure></p><p>如果包含多层子包，那么调用方法前面还有写一长串的包名，特别不方便，我们可以用from…import语句来简化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test.test_cal <span class="keyword">import</span> square</span><br><span class="line">print(square(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></p><p><strong>文中示例代码</strong>： <a href="https://github.com/HamptonChen/python-learning" target="_blank" rel="noopener">python-learning</a></p><p>未完待续，持续更新中……</p><p>参考：<br><a href="https://www.runoob.com/python/python-modules.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-modules.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着程序代码越写越多，一个文件中的代码越来越长，也越来越难以维护。为了编写可维护的代码，我们把很多函数分组，放到不同的文件中，这样每个文件包含的代码相对较少。&lt;/p&gt;
&lt;p&gt;在Python中，一个.py文件就称为一个模块(Module)，里面定义了一些函数、类和变量，也可能
      
    
    </summary>
    
      <category term="Python" scheme="http://www.chenhanpeng.com/categories/Python/"/>
    
    
      <category term="python教程" scheme="http://www.chenhanpeng.com/tags/python%E6%95%99%E7%A8%8B/"/>
    
      <category term="模块" scheme="http://www.chenhanpeng.com/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python从小白到攻城狮(7)——函数</title>
    <link href="http://www.chenhanpeng.com/2019/09/05/python_series/python_7_%E5%87%BD%E6%95%B0/"/>
    <id>http://www.chenhanpeng.com/2019/09/05/python_series/python_7_函数/</id>
    <published>2019-09-05T07:55:35.000Z</published>
    <updated>2019-09-18T11:54:07.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h1><hr><p>函数是组织好的，可复用的，用来实现单一，或相关联功能的代码段。</p><p>函数能提高应用的模块性和代码的复用率。在编程中，常将一些常用的功能写成函数放在函数库中供公共选用。利用好函数，可以减少我们重复编码的工作。</p><p>在前面学习中，我们用过许多Python的内置函数，比如print()、sort()等。</p><h1 id="如何定义一个函数"><a href="#如何定义一个函数" class="headerlink" title="如何定义一个函数"></a>如何定义一个函数</h1><hr><p>根据下面的几个规则，我们可以定义一个函数：</p><ul><li>函数代码块以def关键词开头，后接函数标识符名称和圆括号()。</li><li>任何传入参数和自变量必须放在圆括号中。圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串——用于存放函数说明。</li><li>函数内容以冒号起始，并且缩进。</li><li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回None。也可以不返回。</li></ul><p><strong>语法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span><span class="params">(parameters)</span>:</span></span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> [表达式]</span><br></pre></td></tr></table></figure></p><p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。</p><h1 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h1><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个简单的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_str</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello world!'</span>)</span><br><span class="line"></span><br><span class="line">print_str()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个带参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_string</span><span class="params">(str)</span>:</span></span><br><span class="line">    print(str)</span><br><span class="line"></span><br><span class="line">print_string(<span class="string">'Hello World!!!!'</span>)</span><br></pre></td></tr></table></figure><h1 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h1><hr><p>Python的函数支持返回多个值，我们通过下面的例子来了解其用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回多个值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    x1 = x + <span class="number">2</span></span><br><span class="line">    y1 = y + <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> x1, y1</span><br><span class="line"></span><br><span class="line">x, y = test(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">print(x, y)</span><br></pre></td></tr></table></figure></p><h1 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h1><hr><p>调用函数时可使用的正式参数类型有以下4种：必备参数、关键字参数、默认参数、不定长参数。</p><h2 id="必备参数"><a href="#必备参数" class="headerlink" title="必备参数"></a>必备参数</h2><p>必备参数要以正确的顺序传入函数，调用时的数量必须和声明时的一样。</p><p>下面例子中的print_necessary_params()函数，调用时必须传入一个参数，不然会出现语法错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_necessary_params</span><span class="params">(str1)</span>:</span></span><br><span class="line">    print(str1)</span><br><span class="line"></span><br><span class="line">print_necessary_params()</span><br><span class="line"></span><br><span class="line"><span class="comment">######控制台输出</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"function.py"</span>, line <span class="number">28</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print_necessary_params()</span><br><span class="line">TypeError: print_necessary_params() missing <span class="number">1</span> required positional argument: <span class="string">'str1'</span></span><br></pre></td></tr></table></figure></p><h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_keyword_params</span><span class="params">(id, price)</span>:</span></span><br><span class="line">    print(<span class="string">'id:'</span>, id)</span><br><span class="line">    print(<span class="string">'price'</span>, price)</span><br><span class="line"></span><br><span class="line">print_keyword_params(price=<span class="number">20</span>, id=<span class="number">125345</span>)</span><br></pre></td></tr></table></figure></p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>调用函数时，默认参数的值如果没有传入，则被认为是默认值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_default_param</span><span class="params">(price = <span class="number">50</span>)</span>:</span></span><br><span class="line">    print(price)</span><br><span class="line"></span><br><span class="line">print_default_param()</span><br><span class="line">print_default_param(<span class="number">20</span>)</span><br></pre></td></tr></table></figure></p><h2 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h2><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">([formal_args,] *var_args_tuple )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></p><p>加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(arg1, *params)</span>:</span></span><br><span class="line">    print(<span class="string">'arg1:'</span>, arg1)</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> params:</span><br><span class="line">        print(var)</span><br><span class="line"></span><br><span class="line">print_info(<span class="string">'test'</span>)</span><br><span class="line">print_info(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br></pre></td></tr></table></figure></p><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><hr><p>有时候我们需要反复调用某个函数得到一个最后的值，这个时候使用递归函数是最好的解决方案。</p><p>编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。递归函数不能定义为内联函数。</p><p>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：</p><p>fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n</p><p>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。</p><p>于是，fact(n)用递归的方式写出来就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(fact(<span class="number">5</span>))</span><br><span class="line">print(fact(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节介绍了Python函数的定义，不同类型的参数的使用以及递归函数的用法。</p><p><strong>文中示例代码</strong>： <a href="https://github.com/HamptonChen/python-learning" target="_blank" rel="noopener">python-learning</a></p><p>未完待续，持续更新中……</p><p>参考：<br><a href="https://www.runoob.com/python/python-functions.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-functions.html</a><br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017268131039072" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017268131039072</a><br><a href="http://www.ityouknow.com/python/2019/08/08/python-005.html" target="_blank" rel="noopener">http://www.ityouknow.com/python/2019/08/08/python-005.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是函数&quot;&gt;&lt;a href=&quot;#什么是函数&quot; class=&quot;headerlink&quot; title=&quot;什么是函数&quot;&gt;&lt;/a&gt;什么是函数&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;函数是组织好的，可复用的，用来实现单一，或相关联功能的代码段。&lt;/p&gt;
&lt;p&gt;函数能提高应用的模块性和代码
      
    
    </summary>
    
      <category term="Python" scheme="http://www.chenhanpeng.com/categories/Python/"/>
    
    
      <category term="python教程" scheme="http://www.chenhanpeng.com/tags/python%E6%95%99%E7%A8%8B/"/>
    
      <category term="函数" scheme="http://www.chenhanpeng.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python从小白到攻城狮(6)——条件与循环</title>
    <link href="http://www.chenhanpeng.com/2019/08/27/python_series/python_6_%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/"/>
    <id>http://www.chenhanpeng.com/2019/08/27/python_series/python_6_条件与循环/</id>
    <published>2019-08-27T06:12:08.000Z</published>
    <updated>2019-09-18T12:22:46.283Z</updated>
    
    <content type="html"><![CDATA[<p>在前面几篇文章中，我们学习了列表、元组、字典、集合和字符串等一系列Python的基本数据类型和数据结构。但仅靠这些数据结构类型是无法支持整个程序运行的，在编程中，流程控制是程序运行的基础，它决定了程序按照什么方式去执行。</p><p>接下来给大家介绍Python流程控制相关语法。</p><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><hr><p>Python的条件语句和其他语言一样，都是用<code>if</code>语句实现。</p><p>if语句表示如果发生什么样的条件，执行什么样的逻辑。</p><p>语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_2</span><br><span class="line">...</span><br><span class="line"><span class="keyword">elif</span> condition_i:</span><br><span class="line">    statement_i</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_n</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> id == <span class="number">0</span>:</span><br><span class="line">  print(<span class="string">'red'</span>)</span><br><span class="line"><span class="keyword">elif</span> id == <span class="number">1</span>:</span><br><span class="line">  print(<span class="string">'blue'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'yellow'</span>)</span><br></pre></td></tr></table></figure></p><p>由于Python不支持switch语句，因此，当存在多个条件判断时，我们需要用else if来实现，这在Python中的表达是 <strong>elif</strong>。在条件语句中，可能会有零到多个elif部分，else是可选的。关键字 ‘elif’ 是 ‘else if’ 的缩写，这个可以有效地避免过深的缩进。</p><p>整个条件语句是顺序执行的，如果遇到一个条件满足，比如condition_i满足时，再执行完statement_i后，便会退出整个条件语句，而不会继续向下执行。</p><p>需要注意的是：</p><ul><li>在条件语句末尾必须加上冒号(:)，这是Python特定的语法规范。</li><li>if语句可以单独使用，但elif、else都必须和if成对使用。</li></ul><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>循环，本质上就是遍历集合中的元素。和其他语言一样，python中的循环一般通过for循环和while循环实现。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>语法格式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">for 后面跟变量名，in后面跟序列（主要指列表、元组、字符串、文件等等）</span></span><br><span class="line"><span class="string">for 循环每次从序列中取一个值放到变量中</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &lt;iterable&gt;:</span><br><span class="line">    statements(s)</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">  print(char)</span><br><span class="line"></span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list:</span><br><span class="line">  print(item)</span><br></pre></td></tr></table></figure></p><p>我们也可以通过索引来遍历元素。通常通过<strong>range()</strong>函数拿到索引，再去遍历访问元素。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个等差级数链表</span></span><br><span class="line">range (<span class="keyword">start</span>， <span class="keyword">end</span>， <span class="keyword">scan</span>):</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>start：计数从start开始，默认从0开始。比如range(3)等价于range(0, 3)</li><li>end：计数到end结束，但不包括end。比如range(0, 3)的结果是[0, 1, 2]，但不包含3</li><li>scan：每次跳跃的间距，默认为1。</li></ul><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过range()函数获取索引，再去遍历</span></span><br><span class="line">l = [<span class="string">'zhangsan'</span>, <span class="string">'lisi'</span>, <span class="string">'wangwu'</span>, <span class="string">'sunliu'</span>, <span class="string">'zhouqi'</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(l)):</span><br><span class="line">  print(l[index])</span><br></pre></td></tr></table></figure><p>如果我们同时需要索引和元素时，可以通过Python内置的enumerate()函数来遍历集合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># enumerate()函数来遍历集合</span></span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(l):</span><br><span class="line">  print(<span class="string">'index: &#123;&#125;, value: &#123;&#125;'</span>.format(index, item))</span><br></pre></td></tr></table></figure></p><p>这里单独强调一下字典。字典本身只有键是可迭代的，如果我们要遍历它的值或者键值对，需要通过其内置的函数values()或items()实现。其中，values()返回字典的值的集合，items()返回键值对的集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jack'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"><span class="comment"># 遍历字典的键</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">  print(k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历字典的值</span></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> d.values():</span><br><span class="line">  print(val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历字典的键值对</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">  print(<span class="string">'key: &#123;&#125;, value: &#123;&#125;'</span>.format(k, v))</span><br></pre></td></tr></table></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>while循环，表示当condition满足时，一直重复循环执行某段程序，直到condition不再满足，就跳出循环体。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">    执行语句<span class="built_in">..</span><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p><p>很多时候，for循环和while循环可以相互转换，比如要遍历一个列表，用while循环同样可以完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; len(list):</span><br><span class="line">  print(list[index])</span><br><span class="line">  index += <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>也可以在 while 循环中添加判断逻辑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">  print(<span class="string">'count 小于3'</span>)</span><br><span class="line">  count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'count 大于等于3'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="break用法"><a href="#break用法" class="headerlink" title="break用法"></a>break用法</h2><p>break可以跳出for循环和while循环。如果从for或while循环跳出，相应的循环else代码块将不执行。<br>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">'hello world'</span>:</span><br><span class="line">  <span class="keyword">if</span> char == <span class="string">'l'</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  print(char)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10</span>:</span><br><span class="line">  <span class="keyword">if</span> count &gt;= <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  print(count)</span><br><span class="line">  count += <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="continue用法"><a href="#continue用法" class="headerlink" title="continue用法"></a>continue用法</h2><p>continue语句用来跳过当前循环块中的剩余语句，然后进行下一轮循环。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:   </span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> &gt; <span class="number">0</span>:     <span class="comment"># 非双数时跳过输出</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p><h1 id="条件与循环的复用"><a href="#条件与循环的复用" class="headerlink" title="条件与循环的复用"></a>条件与循环的复用</h1><p>前面我们介绍了条件与循环的基本操作，接下来我们来看看它们的进阶操作，让程序变得更简洁高效。</p><p>在阅读别人代码时，我们会发现，很多将条件和循环并做一行的写法，如：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1 <span class="keyword">if</span> condition <span class="keyword">else</span> expression2 <span class="keyword">for</span> <span class="built_in">item</span> <span class="keyword">in</span> iterable</span><br></pre></td></tr></table></figure></p><p>我们将上面的表达式分解成多行代码，等同于下方的嵌套结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="keyword">if</span> condition1:</span><br><span class="line">        expression1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        expression2</span><br></pre></td></tr></table></figure></p><p>如果表达式中没有else语句，则需要写成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1 <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition1</span><br></pre></td></tr></table></figure></p><p>接下来我们用两个例子来熟悉一下这种写法。</p><p>1、我们要绘制y = 2*|x| + 5 的函数图像，给定集合x的数据点，需要计算出y的数据集合<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">y = [value * <span class="number">2</span> + <span class="number">5</span> <span class="keyword">if</span> value &gt; <span class="number">0</span> <span class="keyword">else</span> -value * <span class="number">2</span> + <span class="number">5</span> <span class="keyword">for</span> value <span class="keyword">in</span> x]</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure></p><p>2、将文件中逐行读取的一个完整语句，按逗号分割单词，去掉首位的空字符，并过滤掉长度小于等于5的单词，最后返回由单词组成的列表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">' Today , is, Sunday '</span></span><br><span class="line">text_list = [s.strip() <span class="keyword">for</span> s <span class="keyword">in</span> text.split(<span class="string">','</span>) <span class="keyword">if</span> len(s) &gt; <span class="number">5</span>]</span><br><span class="line">print(text_list)</span><br></pre></td></tr></table></figure></p><p>当然，这样的复用并不仅仅局限于一个循环。比如：给定两个列表x、y, 要求返回x、y中所有元素对组成的元组，相等的情况除外。那么，我们可以用下面的表达式表示出来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(xx, yy) <span class="keyword">for</span> xx <span class="keyword">in</span> x <span class="keyword">for</span> yy <span class="keyword">in</span> y <span class="keyword">if</span> xx != yy]</span><br></pre></td></tr></table></figure></p><p>写法等价于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> xx <span class="keyword">in</span> x:</span><br><span class="line">    <span class="keyword">for</span> yy <span class="keyword">in</span> y:</span><br><span class="line">        <span class="keyword">if</span> xx != yy:</span><br><span class="line">            l.append((xx, yy))</span><br></pre></td></tr></table></figure></p><p>熟练之后，你会发现这种写法非常方便。当然，如果遇到逻辑很复杂的复用，你可能会觉得写成一行难以理解、容易出错。那种情况下，用正常的形式表达，也不失为一种好的规范和选择。</p><p>下面的一个练习题，大家尝试分别用一行和多行条件循环语句来实现，参考代码点击文末示例代码链接获取。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定下面两个列表attributes和values，要求针对values中每一组子列表value，输出其和attributes中的键对应后的字典，最后返回字典组成的列表。</span><br><span class="line">attributes = ['name', 'dob', 'gender']</span><br><span class="line">values = [['jason', '<span class="number">2000-01-01</span>', 'male'], </span><br><span class="line">['mike', '<span class="number">1999-01-01</span>', 'male'],</span><br><span class="line">['nancy', '<span class="number">2001-02-01</span>', 'female']</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta"># expected output:</span></span><br><span class="line">[&#123;'name': 'jason', 'dob': '<span class="number">2000-01-01</span>', 'gender': 'male'&#125;, </span><br><span class="line">&#123;'name': 'mike', 'dob': '<span class="number">1999-01-01</span>', 'gender': 'male'&#125;, </span><br><span class="line">&#123;'name': 'nancy', 'dob': '<span class="number">2001-02-01</span>', 'gender': 'female'&#125;]</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在条件语句中，if可以单独使用，但是elif和else必须和if同时搭配使用；而If条件语句的判断，除了boolean类型外，其他的最好显示出来。</li><li>在for循环中，如果需要同时访问索引和元素，你可以使用enumerate()函数来简化代码。</li><li>写条件与循环时，合理利用continue或者break来避免复杂的嵌套，是十分重要的。</li><li>要注意条件与循环的复用，简单功能往往可以用一行直接完成，极大地提高代码质量与效率。</li></ul><p><strong>文中示例代码</strong>： <a href="https://github.com/HamptonChen/python-learning" target="_blank" rel="noopener">python-learning</a></p><p>未完待续，持续更新中……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前面几篇文章中，我们学习了列表、元组、字典、集合和字符串等一系列Python的基本数据类型和数据结构。但仅靠这些数据结构类型是无法支持整个程序运行的，在编程中，流程控制是程序运行的基础，它决定了程序按照什么方式去执行。&lt;/p&gt;
&lt;p&gt;接下来给大家介绍Python流程控制相
      
    
    </summary>
    
      <category term="Python" scheme="http://www.chenhanpeng.com/categories/Python/"/>
    
    
      <category term="python教程" scheme="http://www.chenhanpeng.com/tags/python%E6%95%99%E7%A8%8B/"/>
    
      <category term="条件与循环" scheme="http://www.chenhanpeng.com/tags/%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python从小白到攻城狮(5)——深入浅出字符串</title>
    <link href="http://www.chenhanpeng.com/2019/08/25/python_series/python_5_%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.chenhanpeng.com/2019/08/25/python_series/python_5_深入浅出字符串/</id>
    <published>2019-08-25T14:54:02.000Z</published>
    <updated>2019-09-18T12:20:31.910Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://www.chenhanpeng.com/2019/08/06/python_series/Python从小白到攻城狮（2）：数据类型和变量/">《Python从小白到攻城狮（2）：数据类型和变量》</a>中，我们简单介绍过字符串，今天这篇文章，我们将一起学习字符串的更多知识。</p><h1 id="字符串基础"><a href="#字符串基础" class="headerlink" title="字符串基础"></a>字符串基础</h1><hr><p>字符串(string)是Python中很常见的一种数据类型，在日志的打印、函数的注释、数据库的访问、变量的基本操作等等中都用到了字符串。</p><p>字符串是以单引号(<code>&#39;</code>) 、双引号(<code>&quot;</code>) 或者三引号(<code>&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code>)括起来的任意文本。</p><p>在python中单引号、双引号、三引号的字符串是一模一样的，没有区别。</p><p>我们来看一下字符串的几种写法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'zhang san'</span></span><br><span class="line">city = <span class="string">"Fujian"</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">'hello world'</span></span><br><span class="line">s2 = <span class="string">"hello world"</span></span><br><span class="line">s3 = <span class="string">"""hello world"""</span></span><br><span class="line">print(s1 == s2 == s3) <span class="comment"># 返回True说明s1 s2 s3完全一样</span></span><br></pre></td></tr></table></figure></p><p>Python的字符串同时支持三种表达方式，主要是方便我们在字符串中，内嵌带引号的字符串。比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"I'm a coder"</span></span><br><span class="line"><span class="string">"hello 'world'"</span></span><br></pre></td></tr></table></figure></p><p>三引号字符串，主要应用于多行字符串的情境，比如函数的注释等等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_notes</span><span class="params">(value1, value2)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  args:</span></span><br><span class="line"><span class="string">    value1: number</span></span><br><span class="line"><span class="string">    value2: number</span></span><br><span class="line"><span class="string">  return</span></span><br><span class="line"><span class="string">    value1 + value2</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">return</span> value1 + value2</span><br></pre></td></tr></table></figure></p><p>Python也支持转义字符。</p><p>转义字符：用反斜杠开头的字符串，来表示一些特定意义的字符。常见的转义字符见下表：</p><p><img src="/images/articles/2019/python_series/5-1.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'a\nb\tc\''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s)</span><br><span class="line">a</span><br><span class="line">b       c<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(len(s))</span></span><br><span class="line"><span class="string">6</span></span><br></pre></td></tr></table></figure><p>虽然字符串s打印的输出横跨了两行，但是整个字符串s仍然只有6个元素。</p><p>在转义字符中，最常见的是换行符<code>\n</code>的使用。在文件读取时，如果我们一行一行读取，那么每行字符串的末尾，都会包含换行符<code>\n</code>。在最后进行数据处理时，我们往往会去掉每一行的末尾的换行符。</p><h1 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h1><hr><p>Python的字符串支持索引、切片和遍历等操作。</p><p>和其他数据结构一样，字符串的索引也是从0开始，index=0表示第一个元素（字符），[index:index+2]表示第index个元素到index+1个元素组成的子字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">'welcom to china'</span></span><br><span class="line">print(text[<span class="number">0</span>])</span><br><span class="line">print(text[<span class="number">1</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure></p><p>遍历字符串同样很简单，相当于遍历字符串中的每个字符<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">'welcom to china'</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> text:</span><br><span class="line">  print(char)</span><br></pre></td></tr></table></figure></p><p>特别要注意，Python的字符串是不可变的（immutable）。Python中字符串的改变，通常只能通过创建新的字符串来完成。比如：我们想把<code>&#39;hello&#39;</code>的第一个字符<code>&#39;h&#39;</code>，改为大写的<code>&#39;H&#39;</code>，可以采用下面的做法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'H'</span> + s[<span class="number">1</span>:]</span><br><span class="line">s = s.replace(<span class="string">'h'</span>, <span class="string">'H'</span>)</span><br></pre></td></tr></table></figure></p><ul><li>第一种方法，是直接用大写的<code>&#39;H&#39;</code>，通过加号<code>&#39;+&#39;</code>操作符，与原字符串切片操作的子字符串拼接而成新的字符串。</li><li>第二种方法，是直接扫描原字符串，把小写的<code>&#39;h&#39;</code>替换成大写的<code>&#39;H&#39;</code>，得到新的字符串。</li></ul><p>字符串常用的函数还有下面几个：</p><ul><li><strong>string.strip(str)</strong>：表示去掉首尾的str字符串</li><li><strong>string.lstrip(str)</strong>：表示只去掉开头的str字符串</li><li><strong>string.rstrip(str)</strong>：表示只去掉尾部的str字符串</li><li><strong>string.find(sub, start, end)</strong>：表示从start到end查找字符串中子字符串sub的位置等等</li><li><strong>string.split(separator)</strong>：表示把字符串按照separator分割成子字符串，并返回一个分割后子字符串组合的列表</li></ul><p>下面我们通过一些练习来熟悉字符串的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"hello World!"</span></span><br><span class="line"><span class="comment"># 利用len函数计算字符串长度</span></span><br><span class="line">print(len(str1)) <span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字符串首字母大写的拷贝</span></span><br><span class="line">print(str1.capitalize()) <span class="comment"># Hello world!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字符串变大写后的拷贝</span></span><br><span class="line">print(str1.upper()) <span class="comment"># HELLO WORLD!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find函数查找子串的位置</span></span><br><span class="line">print(str1.find(<span class="string">'llo'</span>)) <span class="comment"># 2</span></span><br><span class="line">print(str1.find(<span class="string">'hot'</span>)) <span class="comment"># -1</span></span><br><span class="line"><span class="comment"># # index查找子串，但找不到子串或报错</span></span><br><span class="line"><span class="comment"># print(str1.index('llo'))</span></span><br><span class="line"><span class="comment"># print(str1.index('hot'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否以指定的字符串开头</span></span><br><span class="line">print(str1.startswith(<span class="string">'he'</span>)) <span class="comment"># True</span></span><br><span class="line">print(str1.startswith(<span class="string">'ha'</span>)) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否以指定的字符串结尾</span></span><br><span class="line">print(str1.endswith(<span class="string">'d!'</span>)) <span class="comment"># True</span></span><br><span class="line">print(str1.endswith(<span class="string">'ld'</span>)) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串以指定的宽度居中并在两侧填充指定的字符</span></span><br><span class="line">print(str1.center(<span class="number">50</span>, <span class="string">'='</span>))</span><br><span class="line"><span class="comment"># 将字符串以指定的宽度靠右放置左侧填充指定的字符</span></span><br><span class="line">print(str1.rjust(<span class="number">50</span>, <span class="string">'-'</span>))</span><br><span class="line"></span><br><span class="line">str2 = <span class="string">'1234abcd'</span></span><br><span class="line"><span class="comment"># 索引操作</span></span><br><span class="line">print(str2[<span class="number">3</span>]) <span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 字符串切片操作(从指定的位置开始索引)</span></span><br><span class="line">print(str2[<span class="number">2</span>:<span class="number">5</span>])  <span class="comment"># 34a</span></span><br><span class="line">print(str2[<span class="number">2</span>:])  <span class="comment"># 34abcd</span></span><br><span class="line">print(str2[<span class="number">2</span>::<span class="number">2</span>])  <span class="comment"># 3ac</span></span><br><span class="line">print(str2[::<span class="number">2</span>])  <span class="comment"># 13ac</span></span><br><span class="line">print(str2[::<span class="number">-1</span>])  <span class="comment"># dcba4321</span></span><br><span class="line">print(str2[<span class="number">-3</span>:<span class="number">-1</span>])  <span class="comment"># bc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查字符串是否由数字构成</span></span><br><span class="line">print(str2.isdigit())  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 检查字符串是否以字母构成</span></span><br><span class="line">print(str2.isalpha())  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 检查字符串是否以数字和字母构成</span></span><br><span class="line">print(str2.isalnum())  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">str3 = <span class="string">'  my name is zhangsan  '</span></span><br><span class="line"><span class="comment"># 获得字符串修剪头尾空格后的拷贝</span></span><br><span class="line">print(str3.strip())  <span class="comment"># my name is zhangsan</span></span><br></pre></td></tr></table></figure></p><h1 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h1><hr><h2 id="什么是字符串的格式化？"><a href="#什么是字符串的格式化？" class="headerlink" title="什么是字符串的格式化？"></a>什么是字符串的格式化？</h2><p>通常，我们使用一个字符串作为模板，模板中会有格式符。这些格式符为后续真实值预留位置，以呈现出真实值应该呈现的样式。<br>字符串的格式化，通常会用在程序的输出、logging等场景。</p><p>比如：我们有一个任务，给定一个用户的userid，要去数据库中查询该用户的一些信息，并返回。如果数据库中没有此人的信息，我们通常会记录下来，这样有利于往后的日志分析，或者是线上bug的调试等。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> = <span class="number">123456</span></span><br><span class="line">nanme = 'zhangsan'</span><br><span class="line">print('no data available <span class="keyword">for</span> person <span class="keyword">with</span> <span class="built_in">id</span>: &#123;&#125;, <span class="built_in">name</span>: &#123;&#125;'.format(<span class="built_in">id</span>, <span class="built_in">name</span>))</span><br></pre></td></tr></table></figure></p><p>其中<code>string.format()</code>就是格式化函数，大括号{}就是所谓的格式符，用来为后面的真实值————变量id、name预留位置。</p><p>不过要注意，string.format()是最新的字符串格式函数与规范。自然，我们还有其他的表示方法，比如在Python之前版本中，字符串格式化通常用%来表示，那么上述的例子，就可以写成下面这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'no data available for person with id: %s, name: %s'</span> % (id, name))</span><br></pre></td></tr></table></figure></p><p>其中%s表示字符串型，%d表示整型等等，这些属于常识，你应该都了解。</p><p>当然，现在你写程序时，我还是推荐使用format函数，毕竟这是最新规范，也是官方文档推荐的规范。</p><p>也许有人会问，为什么非要使用格式化函数，上述例子用字符串的拼接不也能完成吗？没错，在很多情况下，字符串拼接确实能满足格式化函数的需求。但是使用格式化函数，更加清晰、易读，并且更加规范，不易出错。</p><p><strong>文中示例代码</strong>： <a href="https://github.com/HamptonChen/python-learning" target="_blank" rel="noopener">python-learning</a></p><p>未完待续，持续更新中……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;http://www.chenhanpeng.com/2019/08/06/python_series/Python从小白到攻城狮（2）：数据类型和变量/&quot;&gt;《Python从小白到攻城狮（2）：数据类型和变量》&lt;/a&gt;中，我们简单介绍过字符串，今天这篇文
      
    
    </summary>
    
      <category term="Python" scheme="http://www.chenhanpeng.com/categories/Python/"/>
    
    
      <category term="python教程" scheme="http://www.chenhanpeng.com/tags/python%E6%95%99%E7%A8%8B/"/>
    
      <category term="字符串" scheme="http://www.chenhanpeng.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python从小白到攻城狮(4)——字典和集合</title>
    <link href="http://www.chenhanpeng.com/2019/08/21/python_series/python_4_%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"/>
    <id>http://www.chenhanpeng.com/2019/08/21/python_series/python_4_字典和集合/</id>
    <published>2019-08-21T12:09:49.000Z</published>
    <updated>2019-09-18T12:20:50.210Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的一篇文章 <a href="http://www.chenhanpeng.com/2019/08/08/python_series/Python从小白到攻城狮（3）：列表和元组/">《Python从小白到攻城狮（3）：列表和元组》</a>中，我们学习了列表和元组，了解了其基本操作和性能比较。今天这篇文章，我们来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在 Python 被广泛使用，并且性能进行了高度优化，其重要性不言而喻。</p><h1 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典(dict)"></a>字典(dict)</h1><hr><h2 id="什么是字典"><a href="#什么是字典" class="headerlink" title="什么是字典"></a>什么是字典</h2><p>字典，dict全称dictionary，在其他语言中也称为map，是一系列无序元素的组合，其长度大小可变，元素可以任意地删减和改变。</p><p>字典的元素是一对键(key)和值(value)的配对，和列表/元组相比，字典的性能更优，尤其是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。</p><h2 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h2><p>字典的创建，通常有下面几种方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>: <span class="string">'jack'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">d2 = dict(&#123;<span class="string">'name'</span>: <span class="string">'jack'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;)</span><br><span class="line">d3 = dict([(<span class="string">'name'</span>, <span class="string">'jack'</span>), (<span class="string">'age'</span>, <span class="number">20</span>), (<span class="string">'gender'</span>, <span class="string">'male'</span>)])</span><br><span class="line">d4 = dict(name=<span class="string">'jack'</span>, age=<span class="number">20</span>, gender=<span class="string">'male'</span>)</span><br><span class="line"></span><br><span class="line">d1 == d2 == d3 == d4</span><br><span class="line"><span class="literal">True</span> <span class="comment"># 返回True，说明创建的4个字典是一样的</span></span><br></pre></td></tr></table></figure></p><h2 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h2><p>刚才我们学习了如何创建字典，我们再来看元素访问的问题。字典访问可以直接索引键，如果不存在，就会抛出异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jack'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">d[<span class="string">'name'</span>]</span><br><span class="line"><span class="string">'jack'</span></span><br><span class="line">d[<span class="string">'location'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'location'</span></span><br></pre></td></tr></table></figure><p>要避免出现key不存在的错误，我们可以通过<code>in</code>来判断key是否存在<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jack'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">'location'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p><p>也可以使用dict提供的<code>get(key, default)</code>函数来进行索引。如果键不存在，调用<code>get()</code>函数可以返回<code>None</code>, 或者返回自己指定的一个默认值。比如下面这个示例，返回了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jack'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">d.get(<span class="string">'name'</span>)</span><br><span class="line"><span class="string">'jack'</span></span><br><span class="line">d.get(<span class="string">'location'</span>, <span class="string">'null'</span>)</span><br><span class="line"><span class="string">'null'</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：返回None的时候Python的交互环境不显示结果。</p></blockquote><h2 id="增、删、更新操作"><a href="#增、删、更新操作" class="headerlink" title="增、删、更新操作"></a>增、删、更新操作</h2><p>字典支持增加、删除、更新等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加</span></span><br><span class="line">d = &#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">d[<span class="string">'gender'</span>] = <span class="string">'male'</span> <span class="comment"># 增加元素对'gender': 'male'</span></span><br><span class="line">d[<span class="string">'dob'</span>] = <span class="string">'1999-02-01'</span> <span class="comment"># 增加元素对'dob': '1999-02-01'</span></span><br><span class="line">d</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>, <span class="string">'dob'</span>: <span class="string">'1999-02-01'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">d[<span class="string">'dob'</span>] = <span class="string">'1998-01-01'</span> <span class="comment"># 更新键'dob'对应的值 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">d.pop(<span class="string">'dob'</span>) <span class="comment"># 删除键为'dob'的元素对</span></span><br><span class="line"><span class="string">'1998-01-01'</span></span><br><span class="line">d</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'jason'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>对于字典，我们通常会根据键或值，进行升序或降序排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'b'</span>: <span class="number">1</span>, <span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">10</span>&#125;</span><br><span class="line">d_sorted_by_key = sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]) <span class="comment"># 根据字典键的升序排序</span></span><br><span class="line">d_sorted_by_value = sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment"># 根据字典值的升序排序</span></span><br><span class="line">d_sorted_by_key</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'b'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">10</span>)]</span><br><span class="line">d_sorted_by_value</span><br><span class="line">[(<span class="string">'b'</span>, <span class="number">1</span>), (<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>当然，因为字典本身是无序的，所以这里返回了一个列表。列表中的每个元素，是由原字典的键和值组成的元组。</p><h1 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h1><hr><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><p>集合和字典类似，也是一组key的集合，但是不存储value。由于key不能重复，所以集合是一系列无序的、唯一的元素组合。</p><h2 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s1 == s2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><strong>集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样</strong>。所以，下面这样的操作是错误的，Python 会抛出异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s[<span class="number">0</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'set'</span> object does <span class="keyword">not</span> support indexing</span><br></pre></td></tr></table></figure><p>和字典一样，我们可以通过<code>in</code>来判断一个元素是否在集合中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>集合也同样支持增加、删除、更新等操作。</strong><br><strong>s.add(x)</strong>：将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</p><p><strong>update()</strong>： 方法用于修改当前集合，可以添加新的元素或集合到当前集合中，如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。</p><p><strong>s.remove( x )</strong>：将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</p><p><strong>s.discard(x)</strong>：移除集合中的元素，且如果元素不存在，不会发生错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.add(<span class="number">4</span>) <span class="comment"># 增加元素 4 到集合</span></span><br><span class="line">s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># update()方法</span></span><br><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s1 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s.update(s1)</span><br><span class="line">print(s)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">s.remove(<span class="number">4</span>) <span class="comment"># 从集合中删除元素 4</span></span><br><span class="line">s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s.remove(<span class="number">6</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">s.discard(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>不过要注意，集合的 pop() 操作是删除集合中最后一个元素，可是集合本身是无序的，你无法知道会删除哪个元素，因此这个操作得谨慎使用。</p><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><p>而对于集合，其排序和前面讲过的列表、元组很类似，直接调用 sorted(set) 即可，结果会返回一个排好序的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">sorted(s) <span class="comment"># 对集合的元素进行升序排序</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h1 id="字典和集合性能"><a href="#字典和集合性能" class="headerlink" title="字典和集合性能"></a>字典和集合性能</h1><hr><p>字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作。那接下来，就来看看，它们在具体场景下的性能表现，以及与列表等其他数据结构的对比。</p><p>比如电商企业的后台，存储了每件产品的ID、名称和价格。现在的需求是，给定某件商品的ID，我们要找出其价格。</p><p>如果我们用列表来存储这些数据结构，并进行查找，相应的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_product_price</span><span class="params">(products, product_id)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> id, price <span class="keyword">in</span> products:</span><br><span class="line">        <span class="keyword">if</span> id == product_id:</span><br><span class="line">            <span class="keyword">return</span> price</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">     </span><br><span class="line">products = [</span><br><span class="line">    (<span class="number">143121312</span>, <span class="number">100</span>), </span><br><span class="line">    (<span class="number">432314553</span>, <span class="number">30</span>),</span><br><span class="line">    (<span class="number">32421912367</span>, <span class="number">150</span>) </span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'The price of product 432314553 is &#123;&#125;'</span>.format(find_product_price(products, <span class="number">432314553</span>)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">The price of product <span class="number">432314553</span> <span class="keyword">is</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>假设列表有 n 个元素，而查找的过程要遍历列表，那么时间复杂度就为 O(n)。即使我们先对列表进行排序，然后使用二分查找，也会需要 O(logn) 的时间复杂度，更何况，列表的排序还需要 O(nlogn) 的时间。</p><p>但如果我们用字典来存储这些数据，那么查找就会非常便捷高效，只需 O(1) 的时间复杂度就可以完成。原因也很简单，刚刚提到过的，字典的内部组成是一张哈希表，你可以直接通过键的哈希值，找到其对应的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">products = &#123;</span><br><span class="line">  <span class="number">143121312</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="number">432314553</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="number">32421912367</span>: <span class="number">150</span></span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">'The price of product 432314553 is &#123;&#125;'</span>.format(products[<span class="number">432314553</span>])) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">The price of product <span class="number">432314553</span> <span class="keyword">is</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>类似的，现在需求变成，要找出这些商品有多少种不同的价格。我们还用同样的方法来比较一下。</p><p>如果还是选择使用列表，对应的代码如下，其中，A 和 B 是两层循环。同样假设原始列表有 n 个元素，那么，在最差情况下，需要 O(n^2) 的时间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list version</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_unique_price_using_list</span><span class="params">(products)</span>:</span></span><br><span class="line">    unique_price_list = []</span><br><span class="line">    <span class="keyword">for</span> _, price <span class="keyword">in</span> products: <span class="comment"># A</span></span><br><span class="line">        <span class="keyword">if</span> price <span class="keyword">not</span> <span class="keyword">in</span> unique_price_list: <span class="comment">#B</span></span><br><span class="line">            unique_price_list.append(price)</span><br><span class="line">    <span class="keyword">return</span> len(unique_price_list)</span><br><span class="line"> </span><br><span class="line">products = [</span><br><span class="line">    (<span class="number">143121312</span>, <span class="number">100</span>), </span><br><span class="line">    (<span class="number">432314553</span>, <span class="number">30</span>),</span><br><span class="line">    (<span class="number">32421912367</span>, <span class="number">150</span>),</span><br><span class="line">    (<span class="number">937153201</span>, <span class="number">30</span>)</span><br><span class="line">]</span><br><span class="line">print(<span class="string">'number of unique price is: &#123;&#125;'</span>.format(find_unique_price_using_list(products)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">number of unique price <span class="keyword">is</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>但如果我们选择使用集合这个数据结构，由于集合是高度优化的哈希表，里面元素不能重复，并且其添加和查找操作只需 O(1) 的复杂度，那么，总的时间复杂度就只有 O(n)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set version</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_unique_price_using_set</span><span class="params">(products)</span>:</span></span><br><span class="line">    unique_price_set = set()</span><br><span class="line">    <span class="keyword">for</span> _, price <span class="keyword">in</span> products:</span><br><span class="line">        unique_price_set.add(price)</span><br><span class="line">    <span class="keyword">return</span> len(unique_price_set)        </span><br><span class="line"> </span><br><span class="line">products = [</span><br><span class="line">    (<span class="number">143121312</span>, <span class="number">100</span>), </span><br><span class="line">    (<span class="number">432314553</span>, <span class="number">30</span>),</span><br><span class="line">    (<span class="number">32421912367</span>, <span class="number">150</span>),</span><br><span class="line">    (<span class="number">937153201</span>, <span class="number">30</span>)</span><br><span class="line">]</span><br><span class="line">print(<span class="string">'number of unique price is: &#123;&#125;'</span>.format(find_unique_price_using_set(products)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">number of unique price <span class="keyword">is</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可能你对这些时间复杂度没有直观的认识，我可以举一个实际工作场景中的例子，让你来感受一下。</p><p>下面的代码，初始化了含有 100,000 个元素的产品，并分别计算了使用列表和集合来统计产品价格数量的运行时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">id = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>)]</span><br><span class="line">price = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">200000</span>, <span class="number">300000</span>)]</span><br><span class="line">products = list(zip(id, price))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 计算列表版本的时间</span></span><br><span class="line">start_using_list = time.perf_counter()</span><br><span class="line">find_unique_price_using_list(products)</span><br><span class="line">end_using_list = time.perf_counter()</span><br><span class="line">print(<span class="string">"time elapse using list: &#123;&#125;"</span>.format(end_using_list - start_using_list))</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">time elapse using list: <span class="number">70.1450754</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 计算集合版本的时间</span></span><br><span class="line">start_using_set = time.perf_counter()</span><br><span class="line">find_unique_price_using_set(products)</span><br><span class="line">end_using_set = time.perf_counter()</span><br><span class="line">print(<span class="string">"time elapse using set: &#123;&#125;"</span>.format(end_using_set - start_using_set))</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">time elapse using set: <span class="number">0.019779799999994907</span></span><br></pre></td></tr></table></figure><p>你可以看到，仅仅十万的数据量，两者的速度差异就如此之大。事实上，大型企业的后台数据往往有上亿乃至十亿数量级，如果使用了不合适的数据结构，就很容易造成服务器的崩溃，不但影响用户体验，并且会给公司带来巨大的财产损失。</p><h1 id="字典和集合的工作原理"><a href="#字典和集合的工作原理" class="headerlink" title="字典和集合的工作原理"></a>字典和集合的工作原理</h1><hr><p>我们通过举例以及与列表的对比，看到了字典和集合操作的高效性。不过，字典和集合为什么能够如此高效，特别是查找、插入和删除操作？</p><p>这当然和字典、集合内部的数据结构密不可分。不同于其他数据结构，字典和集合的内部结构都是一张哈希表。</p><ul><li>对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。</li><li>而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。</li></ul><p>我们来看，老版本 Python 的哈希表结构如下所示：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--<span class="code">+-------------------------------+</span></span><br><span class="line"><span class="code">  | 哈希值 (hash)  键 (key)  值 (value)</span></span><br><span class="line">--<span class="code">+-------------------------------+</span></span><br><span class="line">0 |    hash0      key0    value0</span><br><span class="line">--<span class="code">+-------------------------------+</span></span><br><span class="line">1 |    hash1      key1    value1</span><br><span class="line">--<span class="code">+-------------------------------+</span></span><br><span class="line">2 |    hash2      key2    value2</span><br><span class="line">--<span class="code">+-------------------------------+</span></span><br><span class="line"><span class="bullet">. </span>|           ...</span><br><span class="line">_<span class="emphasis">_+_</span>_____________________________<span class="emphasis">_+</span></span><br></pre></td></tr></table></figure><p>不难想象，随着哈希表的扩张，它会变得越来越稀疏。举个例子，比如我有这样一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'mike'</span>, <span class="string">'dob'</span>: <span class="string">'1999-01-01'</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure><p>那么它会存储为类似下面的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entries = [</span><br><span class="line">[<span class="string">'--'</span>, <span class="string">'--'</span>, <span class="string">'--'</span>]</span><br><span class="line">[<span class="number">-230273521</span>, <span class="string">'dob'</span>, <span class="string">'1999-01-01'</span>],</span><br><span class="line">[<span class="string">'--'</span>, <span class="string">'--'</span>, <span class="string">'--'</span>],</span><br><span class="line">[<span class="string">'--'</span>, <span class="string">'--'</span>, <span class="string">'--'</span>],</span><br><span class="line">[<span class="number">1231236123</span>, <span class="string">'name'</span>, <span class="string">'mike'</span>],</span><br><span class="line">[<span class="string">'--'</span>, <span class="string">'--'</span>, <span class="string">'--'</span>],</span><br><span class="line">[<span class="number">9371539127</span>, <span class="string">'gender'</span>, <span class="string">'male'</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的设计结构显然非常浪费存储空间。为了提高存储空间的利用率，现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开，也就是下面这样新的结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Indices</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="literal">None</span> | index | <span class="literal">None</span> | <span class="literal">None</span> | index | <span class="literal">None</span> | index ...</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> </span><br><span class="line">Entries</span><br><span class="line">--------------------</span><br><span class="line">hash0   key0  value0</span><br><span class="line">---------------------</span><br><span class="line">hash1   key1  value1</span><br><span class="line">---------------------</span><br><span class="line">hash2   key2  value2</span><br><span class="line">---------------------</span><br><span class="line">        ...</span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure><p>那么，刚刚的这个例子，在新的哈希表结构下的存储形式，就会变成下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">indices = [<span class="literal">None</span>, <span class="number">1</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0</span>, <span class="literal">None</span>, <span class="number">2</span>]</span><br><span class="line">entries = [</span><br><span class="line">[<span class="number">1231236123</span>, <span class="string">'name'</span>, <span class="string">'mike'</span>],</span><br><span class="line">[<span class="number">-230273521</span>, <span class="string">'dob'</span>, <span class="string">'1999-01-01'</span>],</span><br><span class="line">[<span class="number">9371539127</span>, <span class="string">'gender'</span>, <span class="string">'male'</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们可以很清晰地看到，空间利用率得到很大的提高。</p><p>清楚了具体的设计结构，我们接着来看这几个操作的工作原理。</p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>每次向字典或集合插入一个元素时，Python 会首先计算键的哈希值（hash(key)），再和 mask = PyDicMinSize - 1 做与操作，计算这个元素应该插入哈希表的位置 index = hash(key) &amp; mask。如果哈希表中此位置是空的，那么这个元素就会被插入其中。</p><p>而如果此位置已被占用，Python 便会比较两个元素的哈希值和键是否相等。</p><ul><li>若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。</li><li>若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），意思是两个元素的键不相等，但是哈希值相等。这种情况下，Python 便会继续寻找表中空余的位置，直到找到位置为止。</li></ul><p>值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始，挨个往后寻找空位。当然，Python 内部对此进行了优化（这一点无需深入了解，你有兴趣可以查看源码，我就不再赘述），让这个步骤更加高效。</p><h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><p>和前面的插入操作类似，Python 会根据哈希值，找到其应该处于的位置；然后，比较哈希表这个位置中元素的哈希值和键，与需要查找的元素是否相等。如果相等，则直接返回；如果不等，则继续查找，直到找到空位或者抛出异常为止。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>对于删除操作，Python 会暂时对这个位置的元素，赋于一个特殊的值，等到重新调整哈希表的大小时，再将其删除。</p><p>不难理解，哈希冲突的发生，往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有 1/3 的剩余空间。随着元素的不停插入，当剩余空间小于 1/3 时，Python 会重新获取更大的内存空间，扩充哈希表。不过，这种情况下，表内所有的元素位置都会被重新排放。</p><p>虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。所以，平均情况下，这仍能保证插入、查找和删除的时间复杂度为 O(1)。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>字典和集合都是无序的数据结构，其内部的哈希表存储结构，保证了其查找、插入、删除操作的高效性。</p><p>所以，字典和集合通常运用在对元素的高效查找、去重等场景。</p><p><strong>文中示例代码</strong>： <a href="https://github.com/HamptonChen/python-learning" target="_blank" rel="noopener">python-learning</a></p><p>未完待续，持续更新中……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前面的一篇文章 &lt;a href=&quot;http://www.chenhanpeng.com/2019/08/08/python_series/Python从小白到攻城狮（3）：列表和元组/&quot;&gt;《Python从小白到攻城狮（3）：列表和元组》&lt;/a&gt;中，我们学习了列表和元组，了
      
    
    </summary>
    
      <category term="Python" scheme="http://www.chenhanpeng.com/categories/Python/"/>
    
    
      <category term="python教程" scheme="http://www.chenhanpeng.com/tags/python%E6%95%99%E7%A8%8B/"/>
    
      <category term="字典/集合" scheme="http://www.chenhanpeng.com/tags/%E5%AD%97%E5%85%B8-%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Python从小白到攻城狮(3)——列表和元组</title>
    <link href="http://www.chenhanpeng.com/2019/08/08/python_series/python_3_%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"/>
    <id>http://www.chenhanpeng.com/2019/08/08/python_series/python_3_列表和元组/</id>
    <published>2019-08-08T01:01:57.000Z</published>
    <updated>2019-09-18T12:21:15.171Z</updated>
    
    <content type="html"><![CDATA[<p>Python内置了多种类型的数据结构，常用的有：列表、元组、集合和字典。</p><p>本文主要介绍列表和元组。</p><hr><h1 id="列表-list-和元组-tuple"><a href="#列表-list-和元组-tuple" class="headerlink" title="列表(list)和元组(tuple)"></a>列表(list)和元组(tuple)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>列表和元组，都是一个可以放置任意数据类型的有序集合。</p><h2 id="列表和元组的区别"><a href="#列表和元组的区别" class="headerlink" title="列表和元组的区别"></a>列表和元组的区别</h2><ul><li><strong>列表是动态的</strong>，长度大小不固定，可以随意增加、删减或者改变元素（mutable）。</li><li><strong>元组是静态的</strong>，长度大小固定，无法增加删减或改变（immutable）。</li></ul><blockquote><p>如果要对已有的元组做任何“改变”，只能重新开辟一块内存，创建新的元组。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表(list)</span></span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list.append(<span class="number">6</span>) <span class="comment"># 添加元素 5 到原列表的末尾</span></span><br><span class="line">print(list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组</span></span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">new_tup = tup + (<span class="number">5</span>, ) <span class="comment"># 创建新的元组 new_tup，并依次填充原元组的值</span></span><br><span class="line">print(new_tup)</span><br></pre></td></tr></table></figure><hr><h1 id="列表和元组的基本操作和注意事项"><a href="#列表和元组的基本操作和注意事项" class="headerlink" title="列表和元组的基本操作和注意事项"></a>列表和元组的基本操作和注意事项</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在python中，列表和元组都支持负数索引，-1表示最后一个元素，-2表示倒数第2个元素，以此类推</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表</span></span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list[<span class="number">0</span>]</span><br><span class="line">list[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组</span></span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">tup[<span class="number">1</span>]</span><br><span class="line">tup[<span class="number">-2</span>]</span><br></pre></td></tr></table></figure><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><p>列表和元组都支持切片操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 返回列表中索引从 1 到 2 的子列表</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">tup[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 返回元组中索引从 1 到 2 的子元组</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h2 id="随意嵌套"><a href="#随意嵌套" class="headerlink" title="随意嵌套"></a>随意嵌套</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]] <span class="comment"># 列表的每一个元素也是一个列表</span></span><br><span class="line"> </span><br><span class="line">tup = ((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)) <span class="comment"># 元组的每一个元素也是一元组</span></span><br></pre></td></tr></table></figure><h2 id="列表和元组的相互转换"><a href="#列表和元组的相互转换" class="headerlink" title="列表和元组的相互转换"></a>列表和元组的相互转换</h2><p>两者可以通过 list() 和 tuple() 函数相互转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line">tuple([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="常用的内置函数"><a href="#常用的内置函数" class="headerlink" title="常用的内置函数"></a>常用的内置函数</h1><ul><li>count(item) 表示统计列表 / 元组中 item 出现的次数。</li><li>index(item) 表示返回列表 / 元组中 item 第一次出现的索引。</li><li>list.reverse() 和 list.sort() 分别表示原地倒转列表和排序（注意，元组没有内置的这两个函数)。</li><li>reversed() 和 sorted() 同样表示对列表 / 元组进行倒转和排序，但是会返回一个倒转后或者排好序的新的列表 / 元组。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>]</span><br><span class="line">l.count(<span class="number">3</span>) </span><br><span class="line"><span class="number">2</span></span><br><span class="line">l.index(<span class="number">7</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">l.reverse()</span><br><span class="line">l</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l.sort()</span><br><span class="line">l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"> </span><br><span class="line">tup = (<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>)</span><br><span class="line">tup.count(<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">tup.index(<span class="number">7</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">list(reversed(tup))</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">sorted(tup)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><hr><h1 id="列表和元组存储方式的差异"><a href="#列表和元组存储方式的差异" class="headerlink" title="列表和元组存储方式的差异"></a>列表和元组存储方式的差异</h1><p>前面我们说过：列表和元组最重要的区别就是，列表是动态的、可变的，而元组是静态的、不可变的。这样的差异，势必会影响两者存储方式。我们先看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l.__sizeof__()</span><br><span class="line"><span class="number">64</span></span><br><span class="line">tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">tup.__sizeof__()</span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们在列表和元组中放置了相同的元素，但是元组的存储空间，却比列表要少 16 字节。这是为什么呢？</p><blockquote><p>事实上，由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于 int 型，8 字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line">l.__sizeof__() // 空列表的存储空间为 <span class="number">40</span> 字节</span><br><span class="line"><span class="number">40</span></span><br><span class="line">l.append(<span class="number">1</span>)</span><br><span class="line">l.__sizeof__() </span><br><span class="line"><span class="number">72</span> // 加入了元素 <span class="number">1</span> 之后，列表为其分配了可以存储 <span class="number">4</span> 个元素的空间 (<span class="number">72</span> - <span class="number">40</span>)/<span class="number">8</span> = <span class="number">4</span></span><br><span class="line">l.append(<span class="number">2</span>) </span><br><span class="line">l.__sizeof__()</span><br><span class="line"><span class="number">72</span> // 由于之前分配了空间，所以加入元素 <span class="number">2</span>，列表空间不变</span><br><span class="line">l.append(<span class="number">3</span>)</span><br><span class="line">l.__sizeof__() </span><br><span class="line"><span class="number">72</span> // 同上</span><br><span class="line">l.append(<span class="number">4</span>)</span><br><span class="line">l.__sizeof__() </span><br><span class="line"><span class="number">72</span> // 同上</span><br><span class="line">l.append(<span class="number">5</span>)</span><br><span class="line">l.__sizeof__() </span><br><span class="line"><span class="number">104</span> // 加入元素 <span class="number">5</span> 之后，列表的空间不足，所以又额外分配了可以存储 <span class="number">4</span> 个元素的空间</span><br></pre></td></tr></table></figure><p>上面的例子，大概描述了列表空间分配的过程。我们可以看到，为了减小每次增加 / 删减操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。</p><p>但是对于元组，情况就不同了。元组长度大小固定，元素不可变，所以存储空间固定。</p><p>在数据量小的情况下，这样的差异可以忽略不计。但是当数据量很大时，比如列表和元组存储元素的个数是一亿，十亿甚至更大数量级时，这种差异就不能忽视了。</p><h2 id="列表和元组的性能"><a href="#列表和元组的性能" class="headerlink" title="列表和元组的性能"></a>列表和元组的性能</h2><p>通过上面列表和元组存储方式的差异的学习，我们可以得出结论：元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。</p><p>另外，Python 会在后台，对静态数据做一些<strong>资源缓存</strong>（resource caching）。通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python 就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。</p><p>但是对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。</p><p>下面的例子，是计算<strong>初始化</strong>一个相同元素的列表和元组分别所需的时间。我们可以看到，元组的初始化速度，要比列表快 5 倍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python -m timeit <span class="string">'x=(1,2,3,4,5,6)'</span></span><br><span class="line"><span class="number">20000000</span> loops, best of <span class="number">5</span>: <span class="number">9.97</span> nsec per loop</span><br><span class="line">python -m timeit <span class="string">'x=[1,2,3,4,5,6]'</span></span><br><span class="line"><span class="number">5000000</span> loops, best of <span class="number">5</span>: <span class="number">50.1</span> nsec per loop</span><br></pre></td></tr></table></figure><p>但如果是<strong>索引操作</strong>的话，两者的速度差别非常小，几乎可以忽略不计。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python -m timeit -s <span class="string">'x=[1,2,3,4,5,6]'</span> <span class="string">'y=x[3]'</span></span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">5</span>: <span class="number">22.2</span> nsec per loop</span><br><span class="line">python -m timeit -s <span class="string">'x=(1,2,3,4,5,6)'</span> <span class="string">'y=x[3]'</span></span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">5</span>: <span class="number">21.9</span> nsec per loop</span><br></pre></td></tr></table></figure><p>当然，如果你想要增加、删减或者改变元素，那么列表显然更优。原因你现在肯定知道了，那就是对于元组，你必须得通过新建一个元组来完成。</p><h2 id="列表和元组的使用场景"><a href="#列表和元组的使用场景" class="headerlink" title="列表和元组的使用场景"></a>列表和元组的使用场景</h2><p>那么列表和元组到底用哪一个呢？根据上面所说的特性，我们具体情况具体分析。</p><p><strong>1.</strong> 如果存储的数据和数量不变，比如你有一个函数，需要返回的是一个地点的经纬度，然后直接传给前端渲染，那么肯定选用元组更合适。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_location</span><span class="params">()</span>:</span></span><br><span class="line">    ..... </span><br><span class="line">    <span class="keyword">return</span> (longitude, latitude)</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 如果存储的数据或数量是可变的，比如社交平台上的一个日志功能，是统计一个用户在一周之内看了哪些用户的帖子，那么则用列表更合适。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viewer_owner_id_list = [] <span class="comment"># 里面的每个元素记录了这个 viewer 一周内看过的所有 owner 的 id</span></span><br><span class="line">records = queryDB(viewer_id) <span class="comment"># 索引数据库，拿到某个 viewer 一周内的日志</span></span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> records:</span><br><span class="line">    viewer_owner_id_list.append(record.id)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>列表和元组都是有序的，可以存储任意数据类型的集合。</li><li>列表是动态的，长度可变，可以随意增加、删减、改变元素。</li><li>元组是静态的，长度大小固定，不可对元素进行增加、删减、改变操作。</li><li>列表的存储空间略大于元组，性能略逊于元组。元组相对列表更轻量级。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python内置了多种类型的数据结构，常用的有：列表、元组、集合和字典。&lt;/p&gt;
&lt;p&gt;本文主要介绍列表和元组。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;列表-list-和元组-tuple&quot;&gt;&lt;a href=&quot;#列表-list-和元组-tuple&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Python" scheme="http://www.chenhanpeng.com/categories/Python/"/>
    
    
      <category term="python教程" scheme="http://www.chenhanpeng.com/tags/python%E6%95%99%E7%A8%8B/"/>
    
      <category term="列表" scheme="http://www.chenhanpeng.com/tags/%E5%88%97%E8%A1%A8/"/>
    
      <category term="元组" scheme="http://www.chenhanpeng.com/tags/%E5%85%83%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Python从小白到攻城狮(2)——数据类型和变量</title>
    <link href="http://www.chenhanpeng.com/2019/08/06/python_series/python_2_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/"/>
    <id>http://www.chenhanpeng.com/2019/08/06/python_series/python_2_数据类型和变量/</id>
    <published>2019-08-06T13:31:03.000Z</published>
    <updated>2019-09-18T12:22:20.675Z</updated>
    
    <content type="html"><![CDATA[<p>本系列Python文章基于Python3版本，关于python的安装和配置自行百度，这里不做详细介绍。</p><p>接下来将介绍Python基础——数据类型和变量。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h1><p>在Python中，能够直接处理的数据类型有以下几种：</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a><strong>整型</strong></h2><p>Python中可以处理任意大的整数，包括负整数。<br>支持二进制（如0b100，换算成十进制是4）、八进制（0o100，换算成十进制是64）、十六进制（0x100，换算成十进制为256）的表示法。</p><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a><strong>浮点型</strong></h2><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是完全相等的。<br>浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。</p><h2 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a><strong>字符串型</strong></h2><p>字符串是以单引号 <code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，比如’Hello’或”Hello”。字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。</p><p>如果字符串内部既包括 <code>&#39;</code> 又包括 <code>&quot;</code> ，可以用转义字符 <code>\</code> 来标识。</p><p>转义字符可以转义很多字符，比如 <code>\n</code> 表示换行， <code>\t</code>表示制表符，字符<code>\</code> 本身也要转义，所以<code>\\</code>表示字符就是\。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'I\'m \"OK\"!'</span>   <span class="comment"># 表示： I'm "OK"!</span></span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'\\\n\\\t\\'</span>)</span><br></pre></td></tr></table></figure><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a><strong>布尔型</strong></h2><p>布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">5</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="复数型"><a href="#复数型" class="headerlink" title="复数型"></a><strong>复数型</strong></h2><p>形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。</p><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a><strong>空值</strong></h2><p>空值是Python一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h1><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a><strong>变量命名</strong></h2><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头。</p><h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a><strong>变量的使用</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">b = <span class="number">14</span></span><br><span class="line">print(a + b)</span><br><span class="line">print(a - b)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用input()函数获取键盘输入</span></span><br><span class="line"><span class="string">使用int()进行类型转换</span></span><br><span class="line"><span class="string">用占位符格式化输出的字符串</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">a = int(input(<span class="string">'a = '</span>))</span><br><span class="line">b = int(input(<span class="string">'b = '</span>))</span><br><span class="line">print(<span class="string">'%d * %d = %d'</span> % (a, b, a * b))</span><br><span class="line">print(<span class="string">'%d / %d = %f'</span> % (a, b, a / b))</span><br><span class="line">print(<span class="string">'%d // %d = %d'</span> % (a, b, a // b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用type()检查变量的类型</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line">b = <span class="number">12.345</span></span><br><span class="line">c = <span class="number">1</span> + <span class="number">5j</span></span><br><span class="line">d = <span class="string">'hello, world'</span></span><br><span class="line">e = <span class="literal">True</span></span><br><span class="line">print(type(a))</span><br><span class="line">print(type(b))</span><br><span class="line">print(type(c))</span><br><span class="line">print(type(d))</span><br><span class="line">print(type(e))</span><br></pre></td></tr></table></figure><p>在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。</p><ul><li>int()：将一个数值或字符串转换成整数，可以指定进制。</li><li>float()：将一个字符串转换成浮点数。</li><li>str()：将指定的对象转换成字符串形式，可以指定编码。</li><li>chr()：将整数转换成该编码对应的字符串（一个字符）。</li><li>ord()：将字符串（一个字符）转换成对应的编码（整数）。</li></ul><hr><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h1><p>Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>[]</code> <code>[:]</code></td><td>下标，切片</td></tr><tr><td><code>**</code></td><td>指数</td></tr><tr><td><code>~</code> <code>+</code> <code>-</code></td><td>按位取反, 正负号</td></tr><tr><td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td><td>乘，除，模，整除</td></tr><tr><td><code>+</code> <code>-</code></td><td>加，减</td></tr><tr><td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td><td>右移，左移</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code>   &#124;</td><td>按位异或，按位或</td></tr><tr><td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td><td>小于等于，小于，大于，大于等于</td></tr><tr><td><code>==</code> <code>!=</code></td><td>等于，不等于</td></tr><tr><td><code>is</code>  <code>is not</code></td><td>身份运算符</td></tr><tr><td><code>in</code> <code>not in</code></td><td>成员运算符</td></tr><tr><td><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr><tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> &#124;= <code>^=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code></td><td>（复合）赋值运算符</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。</p></blockquote><h2 id="运算符的使用"><a href="#运算符的使用" class="headerlink" title="运算符的使用"></a><strong>运算符的使用</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">运算符的使用</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line">d = <span class="number">4</span></span><br><span class="line">e = <span class="number">5</span></span><br><span class="line">a += b</span><br><span class="line">a -= c</span><br><span class="line">a *= d</span><br><span class="line">a /= e</span><br><span class="line">print(<span class="string">"a = "</span>, a)</span><br><span class="line"></span><br><span class="line">flag1 = <span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line">flag2 = <span class="number">2</span> &lt; <span class="number">1</span></span><br><span class="line">flag3 = flag1 <span class="keyword">and</span> flag2</span><br><span class="line">flag4 = flag1 <span class="keyword">or</span> flag2</span><br><span class="line">flag5 = <span class="keyword">not</span> flag1</span><br><span class="line">print(<span class="string">"flag1 = "</span>, flag1)</span><br><span class="line">print(<span class="string">"flag2 = "</span>, flag2)</span><br><span class="line">print(<span class="string">"flag3 = "</span>, flag3)</span><br><span class="line">print(<span class="string">"flag4 = "</span>, flag4)</span><br><span class="line">print(<span class="string">"flag5 = "</span>, flag5)</span><br><span class="line">print(flag1 <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line">print(flag2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列Python文章基于Python3版本，关于python的安装和配置自行百度，这里不做详细介绍。&lt;/p&gt;
&lt;p&gt;接下来将介绍Python基础——数据类型和变量。&lt;/p&gt;
&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Python" scheme="http://www.chenhanpeng.com/categories/Python/"/>
    
    
      <category term="python教程" scheme="http://www.chenhanpeng.com/tags/python%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python从小白到攻城狮(1)——python环境搭建</title>
    <link href="http://www.chenhanpeng.com/2019/08/06/python_series/python_1_python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.chenhanpeng.com/2019/08/06/python_series/python_1_python环境搭建/</id>
    <published>2019-08-06T12:31:03.000Z</published>
    <updated>2019-09-18T12:21:28.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python介绍"><a href="#Python介绍" class="headerlink" title="Python介绍"></a>Python介绍</h1><hr><p>Python是Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言，1991年发布第一版。</p><p>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</p><p>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。</p><ul><li><p>Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</p></li><li><p>Python 是交互式语言： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。</p></li><li><p>Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</p></li><li><p>Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</p></li></ul><h2 id="Python的应用领域"><a href="#Python的应用领域" class="headerlink" title="Python的应用领域"></a>Python的应用领域</h2><p>目前Python在Web应用开发、云基础设施、DevOps、网络爬虫开发、数据分析挖掘、机器学习等领域都有着广泛的应用，因此也产生了Web后端开发、数据接口开发、自动化运维、自动化测试、科学计算和可视化、数据分析、量化交易、机器人开发、图像识别和处理等一系列的职位。</p><h1 id="Python环境搭建"><a href="#Python环境搭建" class="headerlink" title="Python环境搭建"></a>Python环境搭建</h1><hr><p>对于刚开始学习Python的新手，建议安装Anaconda。win 下安装包的时候用 anaconda 比 pip 安装要好一些，pip 有时候会因为一些依赖导致安装失败，这时候anaconda就体现出它对新手的友好。</p><p>搜索Anaconda进入官网或点击下方官网链接进入</p><p><a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">https://www.anaconda.com/distribution/</a></p><p>在页面我们可以看到windows、macOS、linux对应的安装包。</p><p><img src="/images/articles/2019/python_series/install_python_1.png" alt></p><p>如果是初学者，建议下载Python3.X版本，而不是Python2.X。因为python的2和3版本的语法是有差异的，Python2.X将在2020年4月后不再进行任何维护。</p><p>下载安装包，双击安装。</p><p>划重点：安装过程中最好将下图所示的<code>添加到环境变量</code>的选项勾上。</p><p><img src="/images/articles/2019/python_series/install_python_2.png" alt></p><p>安装之后可能程序没有自动配置anaconda环境变量，你需要手动配置！！！</p><p>找到刚才安装的anaconda的目录，找到Scripts，打开，复制路径：</p><p>路径示例：D:\ProgramData\Anaconda3\Scripts。</p><p>配置环境变量：</p><p>在Path后面添加刚才复制的路径，注意与前一个要用英文分号隔开。点击多个确定完成配置。</p><p>打开cmd</p><p>输入python，看到下面的画面，说明安装成功。</p><p><img src="/images/articles/2019/python_series/install_python_3.png" alt></p><p>看到提示符&gt;&gt;&gt;就表示我们已经在Python交互式环境中了，可以输入任何Python代码，回车后会立即得到执行结果。输入<code>exit()</code>并回车，就退出Python交互模式。</p><h1 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a>第一个Python程序</h1><hr><h2 id="Python交互模式"><a href="#Python交互模式" class="headerlink" title="Python交互模式"></a>Python交互模式</h2><p>在Python交互式环境中输入以下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello world!'</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/images/articles/2019/python_series/install_python_4.png" alt></p><h2 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h2><p>通过<code>python  xxx.py</code>运行一个<code>.py</code>文件</p><p>创建一个hello.py文件，文件中输入如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello World!!!'</span>)</span><br></pre></td></tr></table></figure></p><p>cmd的当前目录切换到<code>hello.py</code>所在的目录下，我的目录在 <code>E:\workspace\python-learning\1-环境搭建</code> ，执行下面命令可以进入到相应目录中。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\c</span>henhp&gt;E:</span><br><span class="line"></span><br><span class="line">E:<span class="symbol">\&gt;</span>cd workspace</span><br><span class="line"></span><br><span class="line">E:<span class="symbol">\w</span>orkspace&gt;cd python-learning</span><br><span class="line"></span><br><span class="line">E:<span class="symbol">\w</span>orkspace<span class="symbol">\p</span>ython-learning&gt;cd 1-环境搭建</span><br></pre></td></tr></table></figure><p>在命令行中执行<code>python hello.py</code>，可以得到下面的执行结果：</p><p><img src="/images/articles/2019/python_series/install_python_5.png" alt></p><p>以上内容主要介绍了windows上的环境搭建。关于macOS的环境搭建，可以百度一下安装教程，作为一个没用过mac的人就不在这里就瞎掰了。</p><p><strong>文中示例代码</strong>： <a href="https://github.com/HamptonChen/python-learning" target="_blank" rel="noopener">python-learning</a></p><p>未完待续，持续更新中……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python介绍&quot;&gt;&lt;a href=&quot;#Python介绍&quot; class=&quot;headerlink&quot; title=&quot;Python介绍&quot;&gt;&lt;/a&gt;Python介绍&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Python是Guido van Rossum在1989年圣诞节期间，为了打发无聊
      
    
    </summary>
    
      <category term="Python" scheme="http://www.chenhanpeng.com/categories/Python/"/>
    
    
      <category term="python教程" scheme="http://www.chenhanpeng.com/tags/python%E6%95%99%E7%A8%8B/"/>
    
      <category term="python环境搭建" scheme="http://www.chenhanpeng.com/tags/python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>带你一起用人脸识别技术判断参加美国大选的是不是吴恩达</title>
    <link href="http://www.chenhanpeng.com/2019/07/31/%E5%B8%A6%E4%BD%A0%E4%B8%80%E8%B5%B7%E7%94%A8%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E5%88%A4%E6%96%AD%E5%8F%82%E5%8A%A0%E7%BE%8E%E5%9B%BD%E5%A4%A7%E9%80%89%E7%9A%84%E6%98%AF%E4%B8%8D%E6%98%AF%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <id>http://www.chenhanpeng.com/2019/07/31/带你一起用人脸识别技术判断参加美国大选的是不是吴恩达/</id>
    <published>2019-07-31T03:19:50.000Z</published>
    <updated>2019-07-31T05:35:55.257Z</updated>
    
    <content type="html"><![CDATA[<p>What！吴恩达去参加美国大选了？最近几周，想必很多人都有看到这新闻，是不是在想吴恩达老师是不是有个双胞胎兄弟去参加美国大选了？？？</p><p>答案都不是，参选的是杨安泽，两人不仅长得像，英文名都叫Andrew，Andrew Yang（杨安泽）、Andrew Ng（吴恩达），下面是两个人的照片:<br><img src="/images/articles/2019/TensorFlow/face_recognition_00.png" alt></p><p>是不是分不清啊？没关系，接下来带你一起，用人脸识别技术判断是不是同一个人。</p><p>在上一篇文章中，我们介绍了实现人脸检测的两种方法，接下来要介绍的是人脸识别，通过对比两张人脸，计算其特征相似度，来判断是否是同一个人。</p><h1 id="人脸识别模型"><a href="#人脸识别模型" class="headerlink" title="人脸识别模型"></a>人脸识别模型</h1><h2 id="使用基于NN4改造的CNN模型训练和提取特征"><a href="#使用基于NN4改造的CNN模型训练和提取特征" class="headerlink" title="使用基于NN4改造的CNN模型训练和提取特征"></a>使用基于NN4改造的CNN模型训练和提取特征</h2><p>nn4.small2.v1是FaceNet论文中描述的NN4模型的变体，在OpenFace的模型列表中有nn4.small2详细介绍，具体内容点击下方链接查看<br><a href="https://cmusatyalab.github.io/openface/models-and-accuracies/#model-definitions" target="_blank" rel="noopener">https://cmusatyalab.github.io/openface/models-and-accuracies/#model-definitions</a></p><h3 id="模型列表"><a href="#模型列表" class="headerlink" title="模型列表"></a>模型列表</h3><table><thead><tr><th>Model</th><th>Number of Parameters</th></tr></thead><tbody><tr><td>nn4.small2</td><td>3733968</td></tr><tr><td>nn4.small1</td><td>5579520</td></tr><tr><td>nn4</td><td>6959088</td></tr><tr><td>nn2</td><td>7472144</td></tr></tbody></table><p>本文使用Keras版本中的一种实现，模型定义在model.py<br>Keras版本的github地址：<a href="https://github.com/krasserm/face-recognition" target="_blank" rel="noopener">https://github.com/krasserm/face-recognition</a></p><h3 id="Retrain人脸识别模型工作流程"><a href="#Retrain人脸识别模型工作流程" class="headerlink" title="Retrain人脸识别模型工作流程"></a>Retrain人脸识别模型工作流程</h3><p>1、加载训练数据集<br>2、人脸检测、对齐和提取（使用OpenFace的人脸对齐工具AlignDlib）<br>3、人脸特征向量学习（使用预训练的nn4.small1.v1模型）<br>4、人脸分类（使用KNN或SVM）</p><h1 id="加载训练数据集"><a href="#加载训练数据集" class="headerlink" title="加载训练数据集"></a>加载训练数据集</h1><h2 id="训练集组织形式"><a href="#训练集组织形式" class="headerlink" title="训练集组织形式"></a>训练集组织形式</h2><p>images目录中有3张图像，两张吴恩达(Andrew Ng)的照片，一张杨安泽(Andrew Yang)照片，放一起看两个人还是很像的。</p><p><img src="/images/articles/2019/TensorFlow/face_recogniton_1.png" alt></p><p>最好是1:1比例，如果原图不是1:1比例，提取后的人脸会进行拉伸变换，仅支持.jpg和.jpeg两种格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载训练数据集</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdentityMetadata</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, base, file)</span>:</span></span><br><span class="line">        self.base = base <span class="comment"># 数据集根目录</span></span><br><span class="line">        <span class="comment"># self.name = name # 目录名</span></span><br><span class="line">        self.file = file <span class="comment"># 图像文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.image_path()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">image_path</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> os.path.join(self.base, self.file) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_metadata</span><span class="params">(path)</span>:</span></span><br><span class="line">    metadata = []</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        <span class="comment"># 检查文件名后缀，仅支持 jpg 和 jpeg 两种文件格式</span></span><br><span class="line">        ext = os.path.splitext(f)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> ext == <span class="string">'.jpg'</span> <span class="keyword">or</span> ext == <span class="string">'.jpeg'</span>:</span><br><span class="line">            metadata.append(IdentityMetadata(path, f))</span><br><span class="line">    <span class="keyword">return</span> np.array(metadata)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(path)</span>:</span></span><br><span class="line">    img = cv2.imread(path, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># OpenCV 默认使用 BGR 通道加载图像，转换为 RGB 图像</span></span><br><span class="line">    <span class="keyword">return</span> img[...,::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">metadata = load_metadata(<span class="string">'images'</span>)</span><br></pre></td></tr></table></figure><h1 id="人脸检测、对齐和提取"><a href="#人脸检测、对齐和提取" class="headerlink" title="人脸检测、对齐和提取"></a>人脸检测、对齐和提取</h1><p>从原图提取96*96RGB人脸图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 人脸检测、对齐和提取</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> patches</span><br><span class="line"><span class="keyword">from</span> align <span class="keyword">import</span> AlignDlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 OpenFace 人脸对齐工具，使用 Dlib 提供的 68 个关键点</span></span><br><span class="line">alignment = AlignDlib(<span class="string">'landmarks.dat'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载一张训练图像</span></span><br><span class="line">img = load_image(metadata[<span class="number">0</span>].image_path())</span><br><span class="line"><span class="comment"># 检测人脸并返回边框</span></span><br><span class="line">bb = alignment.getLargestFaceBoundingBox(img)</span><br><span class="line"><span class="comment"># 使用指定的人脸关键点转换图像并截取 96x96 的人脸图像</span></span><br><span class="line">aligned_img = alignment.align(<span class="number">96</span>, img, bb, landmarkIndices=AlignDlib.OUTER_EYES_AND_NOSE)</span><br><span class="line"><span class="comment"># 绘制原图</span></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.subplot(<span class="number">131</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line"><span class="comment"># 绘制带人脸边框的原图</span></span><br><span class="line">plt.subplot(<span class="number">132</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.gca().add_patch(patches.Rectangle((bb.left(), bb.top()), bb.width(), bb.height(), fill=<span class="literal">False</span>, color=<span class="string">'red'</span>))</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line"><span class="comment"># 绘制对齐后截取的 96x96 人脸图像</span></span><br><span class="line">plt.subplot(<span class="number">133</span>)</span><br><span class="line">plt.imshow(aligned_img)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>人脸检测、对齐和提取的结果如下图所示</strong><br><img src="/images/articles/2019/TensorFlow/face_recogniton_figure_0.png" alt></p><h1 id="加载预训练模型nn4-small2-v1"><a href="#加载预训练模型nn4-small2-v1" class="headerlink" title="加载预训练模型nn4.small2.v1"></a>加载预训练模型nn4.small2.v1</h1><p>我们从 OpenFace 提供的 预训练模型 中选择 nn4.small2.v1。</p><p>这些模型使用公开数据集 FaceScrub 和 CASIA-WebFace进行训练。Keras-OpenFace 项目将这些模型文件转换为 csv 文件，然后我们将其转换为 Keras h5 模型文件 nn4.small2.v1.h5。</p><h3 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h3><table><thead><tr><th>Model</th><th>alignment landmarkIndices</th></tr></thead><tbody><tr><td>nn4.v1</td><td>openface.AlignDlib.INNER_EYES_AND_BOTTOM_LIP</td></tr><tr><td>nn4.v2</td><td>openface.AlignDlib.OUTER_EYES_AND_NOSE</td></tr><tr><td>nn4.small1.v1</td><td>openface.AlignDlib.OUTER_EYES_AND_NOSE</td></tr><tr><td>nn4.small2.v1</td><td>openface.AlignDlib.OUTER_EYES_AND_NOSE</td></tr></tbody></table><p>nn4.small2.v1.h5、model.py、align.py这些文件可以从下面github仓库获取：<br><a href="https://github.com/krasserm/face-recognition" target="_blank" rel="noopener">https://github.com/krasserm/face-recognition</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载预训练模型nn4.small2.v1</span></span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> create_model</span><br><span class="line"></span><br><span class="line">nn4_small2_pretrained = create_model()</span><br><span class="line">nn4_small2_pretrained.load_weights(<span class="string">'models/nn4.small2.v1.h5'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">align_image</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> alignment.align(<span class="number">96</span>, img, alignment.getLargestFaceBoundingBox(img), </span><br><span class="line">                           landmarkIndices=AlignDlib.OUTER_EYES_AND_NOSE)</span><br><span class="line"></span><br><span class="line">embedded = np.zeros((metadata.shape[<span class="number">0</span>], <span class="number">128</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, m <span class="keyword">in</span> enumerate(metadata):</span><br><span class="line">    img = load_image(m.image_path())</span><br><span class="line">    img = align_image(img)</span><br><span class="line">    <span class="comment"># 数据规范化</span></span><br><span class="line">    img = (img / <span class="number">255.</span>).astype(np.float32)</span><br><span class="line">    <span class="comment"># 人脸特征向量</span></span><br><span class="line">    embedded[i] = nn4_small2_pretrained.predict(np.expand_dims(img, axis=<span class="number">0</span>))[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="计算人脸特征的欧式距离，计算相似度"><a href="#计算人脸特征的欧式距离，计算相似度" class="headerlink" title="计算人脸特征的欧式距离，计算相似度"></a>计算人脸特征的欧式距离，计算相似度</h1><p>Squared L2 Distance(欧式距离)，计算两个向量之间的距离。</p><p>在上一步，我们获得所有测试人脸的特征向量，我们可以通过计算其之间的距离，来判断人脸的相似度，距离越小，相似度越高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Squared L2 Distance</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(emb1, emb2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(np.square(emb1 - emb2))</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_pair</span><span class="params">(idx1, idx2)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    plt.figure(num=count, figsize=(<span class="number">8</span>,<span class="number">3</span>))</span><br><span class="line">    plt.suptitle(<span class="string">f'Distance = <span class="subst">&#123;distance(embedded[idx1], embedded[idx2]):<span class="number">.2</span>f&#125;</span>'</span>)</span><br><span class="line">    plt.subplot(<span class="number">121</span>)</span><br><span class="line">    plt.imshow(load_image(metadata[idx1].image_path()))</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">122</span>)</span><br><span class="line">    plt.imshow(load_image(metadata[idx2].image_path()))</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_pair(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">show_pair(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">show_pair(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/articles/2019/TensorFlow/face_recogniton_figure_1.png" alt><br><img src="/images/articles/2019/TensorFlow/face_recogniton_figure_2.png" alt><br><img src="/images/articles/2019/TensorFlow/face_recogniton_figure_3.png" alt></p><p>从上面三张结果图我们可以看到，两个吴恩达的照片人脸特征的欧式距离为0.09，吴恩达跟杨安泽的距离为0.33。</p><p>如何利用获得的距离来判断两个张照片上的人是否是同一个人？如果距离值低于某一阈值，则认为是同一个人。</p><p>如何确定阈值，一般通过大量已标记的测试值，阈值从小到大取值，计算获得识别的准确率，取准确率比较高阈值。</p><p>我们这里阈值取0.3，则可以判断测试的人脸1、2为同一个人，3为另一个人，但两个人长得很像。</p><p>完整代码：<br><a href="https://github.com/HamptonChen/tensorflow-learning" target="_blank" rel="noopener">https://github.com/HamptonChen/tensorflow-learning</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;What！吴恩达去参加美国大选了？最近几周，想必很多人都有看到这新闻，是不是在想吴恩达老师是不是有个双胞胎兄弟去参加美国大选了？？？&lt;/p&gt;
&lt;p&gt;答案都不是，参选的是杨安泽，两人不仅长得像，英文名都叫Andrew，Andrew Yang（杨安泽）、Andrew Ng（吴恩
      
    
    </summary>
    
      <category term="机器学习" scheme="http://www.chenhanpeng.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="face_recognition" scheme="http://www.chenhanpeng.com/tags/face-recognition/"/>
    
      <category term="人脸识别" scheme="http://www.chenhanpeng.com/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
      <category term="FaceNet" scheme="http://www.chenhanpeng.com/tags/FaceNet/"/>
    
  </entry>
  
  <entry>
    <title>20行代码实现人脸检测</title>
    <link href="http://www.chenhanpeng.com/2019/07/23/20%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    <id>http://www.chenhanpeng.com/2019/07/23/20行代码实现人脸检测/</id>
    <published>2019-07-22T23:27:50.000Z</published>
    <updated>2019-07-23T00:53:31.776Z</updated>
    
    <content type="html"><![CDATA[<p>如今，“刷脸”已经成为人们生活中的日常，刷脸支付、人脸解锁、门禁等，都运用了人脸识别技术。人脸识别技术已广泛应用于金融、司法、公安、教育、医疗等诸多领域，同时也涌现出如：旷视科技、商汤科技等一批优秀的企业。</p><p>人脸识别算法主要分为三个流程：</p><ul><li>人脸检测（Face Detection）</li><li>人脸对齐（Face Alignment）</li><li>人脸特征表征（Feature Representation）</li></ul><p>本文我们主要针对人脸检测这一部分，利用OpenCV和face_recognition库分别实现图片中的人脸检测。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>Windows 10(x64)</li><li>OpenCV 4.1.0.25</li><li>face_recognition 1.2.3</li></ul><h2 id="使用OpenCV进行人脸检测"><a href="#使用OpenCV进行人脸检测" class="headerlink" title="使用OpenCV进行人脸检测"></a>使用OpenCV进行人脸检测</h2><p>OpenCV实现人脸检测的主要思路为：</p><ul><li>将图片转换成灰度图（降为一维的灰度，减低计算强度）</li><li>使用训练分类器查找人脸</li><li>图片上画矩形</li></ul><h3 id="图片转为灰度图"><a href="#图片转为灰度图" class="headerlink" title="图片转为灰度图"></a>图片转为灰度图</h3><p>使用OpenCV的cvtColor()方法转换图片颜色<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure></p><h3 id="使用训练分类器查找人脸"><a href="#使用训练分类器查找人脸" class="headerlink" title="使用训练分类器查找人脸"></a>使用训练分类器查找人脸</h3><p>在使用OpenCV的人脸检测之前，需要一个人脸训练模型，格式为xml。</p><p>我们这里使用OpenCV提供好的人脸分类模型xml，下载地址如下：<br><a href="https://github.com/opencv/opencv/tree/master/data/haarcascades" target="_blank" rel="noopener">https://github.com/opencv/opencv/tree/master/data/haarcascades</a></p><h3 id="图片上画矩形"><a href="#图片上画矩形" class="headerlink" title="图片上画矩形"></a>图片上画矩形</h3><p>使用OpenCV的rectangle()绘制矩形</p><h3 id="检测结果"><a href="#检测结果" class="headerlink" title="检测结果"></a>检测结果</h3><p><img src="/images/articles/2019/TensorFlow/detection_with_opencv_result.png" alt></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用OpenCV进行人脸检测</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">imagePath = <span class="string">'./test_face_detection.jpg'</span></span><br><span class="line"><span class="comment"># 引入OpenCV提供的人脸分类模型xml</span></span><br><span class="line">cascPath = <span class="string">'./haarcascade_frontalface_default.xml'</span></span><br><span class="line"><span class="comment"># Create the haar cascade</span></span><br><span class="line">faceCascade = cv2.CascadeClassifier(cascPath)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像并转为灰度图</span></span><br><span class="line">image = cv2.imread(imagePath)</span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测图片中的人脸</span></span><br><span class="line">faces = faceCascade.detectMultiScale(</span><br><span class="line">  gray,</span><br><span class="line">  scaleFactor=<span class="number">1.1</span>,</span><br><span class="line">  minNeighbors=<span class="number">4</span>,</span><br><span class="line">  minSize=(<span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">)</span><br><span class="line">color = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 用矩形框将人脸框出来</span></span><br><span class="line"><span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">  cv2.rectangle(image, (x, y), (x+w, y+h), color, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Found &#123;0&#125; faces!"</span>.format(len(faces)))</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>gray：转换的灰度图</li><li>scaleFactor：图像缩放比例，可理解为相机的x倍镜</li><li>minNeighbors：对特征检测点周边多少有效点同时检测，这样可避免因选取的特征检测点太小而导致遗漏</li><li>minSize：特征检测点的最小尺寸</li></ul><h2 id="使用face-recognition库进行人脸检测"><a href="#使用face-recognition库进行人脸检测" class="headerlink" title="使用face_recognition库进行人脸检测"></a>使用face_recognition库进行人脸检测</h2><p>face_recognition库是使用Dlib最先进的面部识别功能构建而成，具有深度学习功能。该模型在LFW上的准确率为99.38%。</p><h3 id="检测结果-1"><a href="#检测结果-1" class="headerlink" title="检测结果"></a>检测结果</h3><p><img src="/images/articles/2019/TensorFlow/detection_with_face_recognition_result.png" alt></p><p>从上面的结果来看，face_recognition库的检测准确率比OpenCV的高。</p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用face_recognition库进行人脸检测</span></span><br><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">imagePath = <span class="string">'./test_face_detection.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用face_recognition加载图片,并检测人脸</span></span><br><span class="line">image = face_recognition.load_image_file(imagePath)</span><br><span class="line"><span class="comment">#检测图片中所有人脸</span></span><br><span class="line">face_locations = face_recognition.face_locations(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用矩形框框出检测到的人脸</span></span><br><span class="line"><span class="keyword">for</span> (top, right, bottom, left) <span class="keyword">in</span> face_locations:</span><br><span class="line">  cv2.rectangle(image, (left, top), (right, bottom), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Found &#123;0&#125; faces!"</span>.format(len(face_locations)))</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="识别人脸关键点"><a href="#识别人脸关键点" class="headerlink" title="识别人脸关键点"></a>识别人脸关键点</h3><p>调用face_recognition.face_landmarks()方法即可得到人脸特征点, 返回一个字典, 下图是返回的数据, 包括chin(下巴), left_eye(左眼)等。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;'chin': [(<span class="number">184</span>, <span class="number">182</span>), (<span class="number">187</span>, <span class="number">198</span>), (<span class="number">191</span>, <span class="number">213</span>), (<span class="number">196</span>, <span class="number">229</span>), (<span class="number">202</span>, <span class="number">243</span>), (<span class="number">211</span>, <span class="number">256</span>), (<span class="number">223</span>, <span class="number">266</span>), (<span class="number">236</span>, <span class="number">275</span>), (<span class="number">251</span>, <span class="number">277</span>), (<span class="number">267</span>, <span class="number">273</span>), (<span class="number">281</span>, <span class="number">263</span>), (<span class="number">295</span>, <span class="number">251</span>), (<span class="number">304</span>, <span class="number">236</span>), (<span class="number">308</span>, <span class="number">219</span>), (<span class="number">309</span>, <span class="number">201</span>), (<span class="number">311</span>, <span class="number">184</span>), (<span class="number">311</span>, <span class="number">167</span>)], 'left_eyebrow': [(<span class="number">192</span>, <span class="number">170</span>), (<span class="number">199</span>, <span class="number">163</span>), (<span class="number">210</span>, <span class="number">162</span>), (<span class="number">220</span>, <span class="number">163</span>), (<span class="number">231</span>, <span class="number">166</span>)], 'right_eyebrow': [(<span class="number">246</span>, <span class="number">163</span>), (<span class="number">258</span>, <span class="number">158</span>), (<span class="number">269</span>, <span class="number">155</span>), (<span class="number">281</span>, <span class="number">155</span>), (<span class="number">291</span>, <span class="number">160</span>)], 'nose_bridge': [(<span class="number">240</span>, <span class="number">177</span>), (<span class="number">240</span>, <span class="number">187</span>), (<span class="number">240</span>, <span class="number">197</span>), (<span class="number">241</span>, <span class="number">208</span>)], 'nose_tip': [(<span class="number">233</span>, <span class="number">217</span>), (<span class="number">238</span>, <span class="number">218</span>), (<span class="number">243</span>, <span class="number">219</span>), (<span class="number">248</span>, <span class="number">217</span>), (<span class="number">254</span>, <span class="number">215</span>)], 'left_eye': [(<span class="number">205</span>, <span class="number">181</span>), (<span class="number">211</span>, <span class="number">177</span>), (<span class="number">219</span>, <span class="number">177</span>), (<span class="number">226</span>, <span class="number">180</span>), (<span class="number">219</span>, <span class="number">183</span>), (<span class="number">211</span>, <span class="number">183</span>)], 'right_eye': [(<span class="number">258</span>, <span class="number">177</span>), (<span class="number">264</span>, <span class="number">172</span>), (<span class="number">272</span>, <span class="number">172</span>), (<span class="number">279</span>, <span class="number">174</span>), (<span class="number">273</span>, <span class="number">178</span>), (<span class="number">265</span>, <span class="number">178</span>)], 'top_lip': [(<span class="number">228</span>, <span class="number">242</span>), (<span class="number">234</span>, <span class="number">236</span>), (<span class="number">240</span>, <span class="number">231</span>), (<span class="number">245</span>, <span class="number">232</span>), (<span class="number">250</span>, <span class="number">230</span>), (<span class="number">258</span>, <span class="number">233</span>), (<span class="number">267</span>, <span class="number">238</span>), (<span class="number">263</span>, <span class="number">238</span>), (<span class="number">251</span>, <span class="number">237</span>), (<span class="number">246</span>, <span class="number">238</span>), (<span class="number">241</span>, <span class="number">238</span>), (<span class="number">232</span>, <span class="number">242</span>)], 'bottom_lip': [(<span class="number">267</span>, <span class="number">238</span>), (<span class="number">259</span>, <span class="number">243</span>), (<span class="number">252</span>, <span class="number">247</span>), (<span class="number">247</span>, <span class="number">248</span>), (<span class="number">241</span>, <span class="number">248</span>), (<span class="number">235</span>, <span class="number">246</span>), (<span class="number">228</span>, <span class="number">242</span>), (<span class="number">232</span>, <span class="number">242</span>), (<span class="number">241</span>, <span class="number">239</span>), (<span class="number">246</span>, <span class="number">239</span>), (<span class="number">251</span>, <span class="number">238</span>), (<span class="number">263</span>, <span class="number">238</span>)]&#125;</span><br></pre></td></tr></table></figure></p><h4 id="人脸关键点检测结果"><a href="#人脸关键点检测结果" class="headerlink" title="人脸关键点检测结果"></a>人脸关键点检测结果</h4><p><img src="/images/articles/2019/TensorFlow/test_face_landmarks_result.png" alt></p><h4 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用face_recognition.face_landmarks()方法得到人脸特征点</span></span><br><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">imagePath = <span class="string">'./test_face_landmarks.jpg'</span></span><br><span class="line"></span><br><span class="line">image = face_recognition.load_image_file(imagePath)</span><br><span class="line">face_landmarks_list = face_recognition.face_landmarks(image)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> face_landmarks_list:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> each.keys():</span><br><span class="line">    <span class="keyword">for</span> any <span class="keyword">in</span> each[i]:</span><br><span class="line">      image = cv2.circle(image, any, <span class="number">2</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Face landmarks"</span>)</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>本文只是使用OpenCV和face_recognition库进行实现简单的人脸检测，基于此我们还可以进行许多好玩的事情，比如：脸部轮廓绘制、数字化妆、头像特效合成等等。</p><p>上述人脸检测demo的github地址：<br><a href="https://github.com/HamptonChen/tensorflow-learning/tree/master/face_detection" target="_blank" rel="noopener">https://github.com/HamptonChen/tensorflow-learning/tree/master/face_detection</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如今，“刷脸”已经成为人们生活中的日常，刷脸支付、人脸解锁、门禁等，都运用了人脸识别技术。人脸识别技术已广泛应用于金融、司法、公安、教育、医疗等诸多领域，同时也涌现出如：旷视科技、商汤科技等一批优秀的企业。&lt;/p&gt;
&lt;p&gt;人脸识别算法主要分为三个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="机器学习" scheme="http://www.chenhanpeng.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人脸检测" scheme="http://www.chenhanpeng.com/tags/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    
      <category term="OpenCV" scheme="http://www.chenhanpeng.com/tags/OpenCV/"/>
    
      <category term="face_recognition" scheme="http://www.chenhanpeng.com/tags/face-recognition/"/>
    
  </entry>
  
  <entry>
    <title>你还在用二分法求2个鸡蛋100层楼的问题吗？</title>
    <link href="http://www.chenhanpeng.com/2019/07/10/interview_questions/2%E4%B8%AA%E9%B8%A1%E8%9B%8B100%E5%B1%82%E6%A5%BC/"/>
    <id>http://www.chenhanpeng.com/2019/07/10/interview_questions/2个鸡蛋100层楼/</id>
    <published>2019-07-10T15:56:13.000Z</published>
    <updated>2019-07-10T16:05:27.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>2个鸡蛋，100层楼，如何用最少的试验次数得到在鸡蛋落下不碎的最高层数？这一据说曾被谷歌纳入校园招聘题库的经典面试题，想必许多人都曾遇到过，又有多少人与我一样，不加思索就直接回答用二分法查找的？</p><p>但是，二分法真的是最优试验方法吗？接下来我们来分析几种解法。</p><p>首先我们先认真看一下完整的题目(之前做过这道题的同学可以跳过这一步)：</p><p>原题：两个软硬程度一样但未知的鸡蛋，它们有可能都在一楼扔下来就摔碎，也有可能从100层楼上扔下来也没事。有座100层的楼，要你用这两个鸡蛋确定哪一层是鸡蛋可以安全落下的最高位置。可以摔碎两个鸡蛋，在最坏情况下，如何用最少的试验次数得到鸡蛋落下不会被摔碎的最高层数？</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="最笨的方法：遍历查找"><a href="#最笨的方法：遍历查找" class="headerlink" title="最笨的方法：遍历查找"></a>最笨的方法：遍历查找</h2><p>把其中的一个鸡蛋，从第1层开始往下扔。如果第一层没碎，换到第2层扔；如果第2层没碎，换到第3层扔…假设第50层没碎，第51层碎了，说明鸡蛋落下不会摔碎的最高层数为第50层。</p><p>这个方法在最坏情况下，需要扔99次。</p><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>采用二分查找的方法：</p><p>把第一个鸡蛋从一半楼层(50层)扔下。</p><p>如果鸡蛋碎了，则第二个鸡蛋就从第1层开始扔，一层一层增长，直到49层。</p><p>如果第一枚鸡蛋在50层没有被摔碎，则继续使用二分法，从剩余的楼层的一半(75层)开始往下扔…</p><p><img src="/images/articles/interviewQuestions/two_egg_one_hundred_floor_1.png" alt></p><p>在最坏情况下，这种二分法需要进行50次试验0。</p><h2 id="平方根法"><a href="#平方根法" class="headerlink" title="平方根法"></a>平方根法</h2><p>如何让第一个鸡蛋和第二个鸡蛋的尝试次数尽可能均衡？我们做一个平方根运算，100的平方根为10。</p><p>因此我们第一个鸡蛋每10层扔一次，第一次从第10层扔，没碎的话再加10层，即从20层扔….一直扔到100层。</p><p>第二个鸡蛋从第一个鸡蛋碎掉的n层往下9层，即n-9层开始一层一层往上试。</p><p><img src="/images/articles/interviewQuestions/two_egg_one_hundred_floor_2.png" alt></p><p>这种方法最好的情况为：第一个鸡蛋在第10层碎掉，尝试次数 1 + 9 = 10 次。</p><p>最坏的情况为：第一个鸡蛋在第100层碎掉，尝试次数为 10 + 9 = 19 次。</p><p>这样子看来平方根的方法算是比较好的方法，那么还有更好的方法吗？</p><h2 id="反向思考"><a href="#反向思考" class="headerlink" title="反向思考"></a>反向思考</h2><p>我们反向思考一下这个题目：假设题目存在最优解，这个最优解的最坏情况尝试x次，那么我们第一次扔要选择在第几层？</p><p>假设第一次扔在x+1层：如果第一个鸡蛋碎了，那么第二个鸡蛋就只能从第1层开始一层一层扔，一直扔到第x层。这样总共尝试了x+1次，与最优解的尝试x次相悖。</p><p>假设第一次在x-1层：如果第一个鸡蛋碎了，那么第2个鸡蛋就要从第1层开始扔，一直到x-2层，共尝试了x-2+1=x-1次，虽然没有超出假设次数，但似乎有些过于保守。</p><p>假设第一次扔在第x层：</p><p>如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-1层。这样，我们总共尝试了x-1+1 = x次，刚刚好没有超出假设次数。</p><p>恰恰是从第x层开始扔，选择高一层或第一层都不合适。</p><p>如果第一个鸡蛋没碎，问题就变成了：在100-x层楼往下扔，要求尝试次数不超过x-1次。</p><p>那么第二次的尝试次数的上限变为x-1次，所以第2次试验的楼层跨度为x-1层，真实层数为x+x-1层。</p><p><img src="/images/articles/interviewQuestions/two_egg_one_hundred_floor_3.png" alt></p><p>以此类推我们可以列出楼层的方程式： x + (x - 1) + (x - 2) + … + 1 = 100</p><p>接下来就是求解方程式，我们将这种方法称为解方程法：</p><h2 id="解方程法"><a href="#解方程法" class="headerlink" title="解方程法"></a>解方程法</h2><p>x + (x - 1) + (x - 2) + … + 1 = 100  =&gt; (x + 1) * x / 2 = 100</p><p>向上取整得到x=14</p><p>即最优解的最坏尝试次数为14次，第1个鸡蛋开始扔的层数也为14层。</p><p>第一个鸡蛋没碎的情况下，所尝试的楼层为：14， 27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100</p><p>假设鸡蛋不会被摔碎的最高楼层为55层，那么第一个鸡蛋尝试的楼层为14，27,39,50,60，在第60层碎了；</p><p>第二个鸡蛋从51层开始， 51,52,53,54,55,56，第56层碎了，则尝试次数为5 + 6 = 11 &lt; 14</p><p>这道面试题的解法到此到一段落，现在你还会认为二分法是这道题的最优解吗？</p><p>其实这道题还可以衍生下面的问题：<br>总共有M层楼，N个鸡蛋，要找到鸡蛋不被摔碎的最高楼层，需要尝试几次？</p><p>这个问题就不在这里展开讨论了，大家可以自行尝试求解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;2个鸡蛋，100层楼，如何用最少的试验次数得到在鸡蛋落下不碎的最高层数？这一据说曾被谷歌纳入校园招聘题库的经典面试题，想必许多人都曾遇到过，
      
    
    </summary>
    
      <category term="面试题目" scheme="http://www.chenhanpeng.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="面试题目" scheme="http://www.chenhanpeng.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    
      <category term="2个鸡蛋100层楼" scheme="http://www.chenhanpeng.com/tags/2%E4%B8%AA%E9%B8%A1%E8%9B%8B100%E5%B1%82%E6%A5%BC/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序使用otp算法踩坑总结</title>
    <link href="http://www.chenhanpeng.com/2019/07/09/bug_summary/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8otp%E7%AE%97%E6%B3%95%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
    <id>http://www.chenhanpeng.com/2019/07/09/bug_summary/微信小程序使用otp算法踩坑总结/</id>
    <published>2019-07-09T14:13:05.000Z</published>
    <updated>2019-07-09T14:22:43.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前两天项目有个类似动态口令的功能要实现，团队最终决定使用OTP算法来实现：前端先向后端请求获取用户的密钥(secret)，将之保存在缓存中，之后前端根据该secret，使用OTP算法中的TOTP方式生成6位动态密码，将6位动态密码传到后台验证。</p><h1 id="OTP"><a href="#OTP" class="headerlink" title="OTP"></a>OTP</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>OTP(One-Time-Password)：一次性密码，也称为动态口令。是使用密码技术实现的在客户端和服务端之间通过共享密钥的一种认证技术，是一种强认证技术，是增强目前静态密码口令认证的一种非常方便的技术手段，是一种重要的双因素认证技术。</p><h2 id="1-2-OTP认证原理"><a href="#1-2-OTP认证原理" class="headerlink" title="1.2 OTP认证原理"></a>1.2 OTP认证原理</h2><p>动态口令的基本认证原理是在认证双方共享密钥，也称种子密钥，并使用同一个种子密钥对某一个事件计数、或时间值、或异步挑战数进行密码算法计算，使用的算法有对称算法、HASH、HMAC，之后比较计算值是否一致进行认证。可以做到一次一个动态口令，使用后作废，口令长度通常为6-8个数字，使用方便，与通常的静态口令认证方式类似。</p><h2 id="1-3-OTP实现方式"><a href="#1-3-OTP实现方式" class="headerlink" title="1.3 OTP实现方式"></a>1.3 OTP实现方式</h2><ul><li>时间同步(TOTP)</li><li>事件同步(HOTP)</li><li>挑战/应答(OCRA)</li></ul><p>本文内容主要是小程序使用OTP算法踩坑总结，不对OTP算法的三种实现方式的工作原理进行详细介绍，有兴趣的朋友自行查找相关资料。</p><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><h2 id="2-1-后端使用的otp库说明"><a href="#2-1-后端使用的otp库说明" class="headerlink" title="2.1 后端使用的otp库说明"></a>2.1 后端使用的otp库说明</h2><p>opt算法有许多现成的库可以直接调用，后端使用的是aerogear-otp-java这个库，问题不在后端，这里就不对这个库进行讲解，有兴趣的朋友可以自己查看：<br>github地址： <a href="https://github.com/aerogear/aerogear-otp-java" target="_blank" rel="noopener">https://github.com/aerogear/aerogear-otp-java</a></p><h2 id="2-2-踩坑前提"><a href="#2-2-踩坑前提" class="headerlink" title="2.2 踩坑前提"></a>2.2 踩坑前提</h2><p>我们的微信小程序项目目前不支持引用第三方的npm包，所以要使用第三方的js库，需要将其js文件下载放到小程序目录中，通过require去引入。还有一点就是小程序项目还不支持node.js，如果js库有相关的node.js代码，还需要做一些改造。以上两点背景给我挖了一个大坑往里跳。</p><h2 id="2-3-跳入第一个坑"><a href="#2-3-跳入第一个坑" class="headerlink" title="2.3 跳入第一个坑"></a>2.3 跳入第一个坑</h2><p>我们先找可用的otp的js库，上github一搜，还是很多的，先选一个start数量比较的的：<a href="https://github.com/yeojz/otplib。" target="_blank" rel="noopener">https://github.com/yeojz/otplib。</a></p><p>我们现在node.js环境上对 <strong>otplib</strong> 这个进行测试：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> authenticator = <span class="built_in">require</span>(<span class="string">'otplib/authenticator'</span>);</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line">authenticator.options = &#123; crypto &#125;;</span><br><span class="line"><span class="keyword">const</span> secret = <span class="string">'BYYHJ5R6C3DNZJX3'</span></span><br><span class="line"><span class="keyword">const</span> token = authenticator.generate(secret);</span><br><span class="line"><span class="built_in">console</span>.log(token);</span><br></pre></td></tr></table></figure></p><p>执行上面的代码，可以获得6位动态密码，拿到后端验证，<strong>验证不通过</strong>…各种尝试和排查后，放弃了，这个库和后端的aerogear-otp-java不兼容，尴尬。。。</p><h2 id="2-4-跳入第二个坑"><a href="#2-4-跳入第二个坑" class="headerlink" title="2.4 跳入第二个坑"></a>2.4 跳入第二个坑</h2><p>又到github上一通找，各种尝试，终于找到一个可以与aerogear-otp-java兼容的js库：node-lib-otp<br>github地址： <a href="https://github.com/JCloudYu/node-lib-otp" target="_blank" rel="noopener">https://github.com/JCloudYu/node-lib-otp</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> otp = <span class="built_in">require</span>( <span class="string">'lib-otp'</span> );</span><br><span class="line"><span class="keyword">let</span> otpObj = otp(&#123;</span><br><span class="line">secret:<span class="string">'BYYHJ5R6C3DNZJX3'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(otpObj.totp(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>将生成的6位动态密码传到后台验证，通过。</p><p>心想终于找到能用的了，有种胜利就在眼前的喜悦，马不停蹄下载相关js，着手修改其中的node.js代码，改到一半发现该库引用了太多node.js的写法和库，短时间内无法完成修改并保证可用，放弃该库了。。。</p><h3 id="2-5-出坑"><a href="#2-5-出坑" class="headerlink" title="2.5 出坑"></a>2.5 出坑</h3><p>在github上搜索许久仍旧未找到合适的js库，突然灵光一闪上码云找一下，搜索结果第一个superzlc/otp有写小程序，尝试一下。<br>地址：<a href="https://gitee.com/superzlc/otp/tree/master" target="_blank" rel="noopener">https://gitee.com/superzlc/otp/tree/master</a><br>下载js，引入该库生成动态密码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> otp = <span class="built_in">require</span>(<span class="string">'./libs/otp'</span>)</span><br><span class="line"><span class="keyword">const</span> TOTP = otp.TOTP</span><br><span class="line"><span class="keyword">const</span> token = <span class="keyword">new</span> TOTP(<span class="string">'BYYHJ5R6C3DNZJX3'</span>, <span class="number">3</span>, <span class="number">30</span>).gen()</span><br><span class="line"><span class="built_in">console</span>.log(token)</span><br></pre></td></tr></table></figure></p><p>验证通过，还不用修改代码，终于爬出坑了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>OTP算法中的TOTP方式生成6位动态密码可用库如下：</p><ul><li>后端java ： <a href="https://github.com/aerogear/aerogear-otp-java" target="_blank" rel="noopener">https://github.com/aerogear/aerogear-otp-java</a></li><li>node.js:   <a href="https://github.com/JCloudYu/node-lib-otp" target="_blank" rel="noopener">https://github.com/JCloudYu/node-lib-otp</a></li><li>小程序纯js：<a href="https://gitee.com/superzlc/otp/tree/master" target="_blank" rel="noopener">https://gitee.com/superzlc/otp/tree/master</a></li></ul><p><strong>注意点：</strong>前后端的计数值应一致，否则无法验证通过</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前两天项目有个类似动态口令的功能要实现，团队最终决定使用OTP算法来实现：前端先向后端请求获取用户的密钥(secret)，将之保存在缓存中，
      
    
    </summary>
    
      <category term="问题总结" scheme="http://www.chenhanpeng.com/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="otp算法" scheme="http://www.chenhanpeng.com/tags/otp%E7%AE%97%E6%B3%95/"/>
    
      <category term="小程序" scheme="http://www.chenhanpeng.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>PDF.js实现在线展示pdf文件</title>
    <link href="http://www.chenhanpeng.com/2019/06/28/PDFJS%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E5%B1%95%E7%A4%BAPDF%E6%96%87%E4%BB%B6/"/>
    <id>http://www.chenhanpeng.com/2019/06/28/PDFJS实现在线展示PDF文件/</id>
    <published>2019-06-27T16:03:24.000Z</published>
    <updated>2019-07-01T00:38:12.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现在很多项目开发过程中都会碰到PDF在线预览的需求，对于PC端浏览器，一般直接提供PDF文件，iframe一下就可以直接预览。但在移动端要预览PDF则较为麻烦，有些浏览器检测到文件流，就会直接下载，无法实现预览功能。</p><p>PDFJS就是解决这一问题比较好用的一款插件。</p><h1 id="PDF-js"><a href="#PDF-js" class="headerlink" title="PDF.js"></a>PDF.js</h1><p>PDF.js是一个使用HTML5构建的可移植文档格式库。</p><p>PDF.js官网：<a href="http://mozilla.github.io/pdf.js/" target="_blank" rel="noopener">http://mozilla.github.io/pdf.js/</a></p><p>官网给出的使用方法是将PDF.js下载到项目静态资源目录中，在html文件中引入pdf.js去使用，但这样会导致最后项目编译打包后的资源包比较大。</p><p>pdfjs-dist这一node库这好可以解决我们的问题。pdfjs-dist是pdf.js源代码的预构建版本，我们直接在项目中引入该库即可使用，接下来我们介绍如何使用。</p><p>需要预览的PDF一般是后台接口返回的base64编码数据或者是本地上传获取到文件，接下来我们在vue工程上实现本地上传PDF文件，获取文件的base64编码，利用pdf.js实现预览效果。</p><h1 id="基于Vue工程实现PDF在线预览"><a href="#基于Vue工程实现PDF在线预览" class="headerlink" title="基于Vue工程实现PDF在线预览"></a>基于Vue工程实现PDF在线预览</h1><h2 id="1、安装pdfjs-dist依赖"><a href="#1、安装pdfjs-dist依赖" class="headerlink" title="1、安装pdfjs-dist依赖"></a>1、安装pdfjs-dist依赖</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> pdfjs-dist</span><br></pre></td></tr></table></figure><h2 id="2、初始化PDF，核心代码"><a href="#2、初始化PDF，核心代码" class="headerlink" title="2、初始化PDF，核心代码"></a>2、初始化PDF，核心代码</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">previewPDF</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 引入pdf.js的字体</span></span><br><span class="line">  let CMAP_URL = <span class="string">'https://unpkg.com/pdfjs-dist@2.0.943/cmaps/'</span></span><br><span class="line">  <span class="comment">//读取base64的pdf流文件</span></span><br><span class="line">  let loadingTask = pdfJS.getDocument(&#123;</span><br><span class="line">    data: this<span class="selector-class">.pdfData</span>, <span class="comment">// PDF base64编码</span></span><br><span class="line">    cMapUrl: CMAP_URL,</span><br><span class="line">    cMapPacked: true</span><br><span class="line">  &#125;)</span><br><span class="line">  loadingTask<span class="selector-class">.promise</span><span class="selector-class">.then</span>((pdf) =&gt; &#123;</span><br><span class="line">    this<span class="selector-class">.loadFinished</span> = true</span><br><span class="line">    let numPages = pdf.numPages</span><br><span class="line">    let pageNumber = <span class="number">1</span></span><br><span class="line">    this.getPage(pdf, pageNumber, numPages)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">getPage</span><span class="params">(pdf, pageNumber, numPages)</span></span> &#123;</span><br><span class="line">  let _this = this</span><br><span class="line">  pdf.getPage(pageNumber)</span><br><span class="line">    .then((page) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 获取DOM中为预览PDF准备好的canvasDOM对象</span></span><br><span class="line">      let <span class="selector-tag">canvas</span> = this.<span class="variable">$refs</span>.myCanvas</span><br><span class="line">      let viewport = page.getViewport(_this.scale)</span><br><span class="line">      <span class="selector-tag">canvas</span><span class="selector-class">.height</span> = viewport.<span class="attribute">height</span></span><br><span class="line">      <span class="selector-tag">canvas</span><span class="selector-class">.width</span> = viewport.<span class="attribute">width</span></span><br><span class="line"></span><br><span class="line">      let ctx = <span class="selector-tag">canvas</span>.getContext(<span class="string">'2d'</span>)</span><br><span class="line">      let renderContext = &#123;</span><br><span class="line">        canvasContext: ctx,</span><br><span class="line">        viewport: viewport</span><br><span class="line">      &#125;</span><br><span class="line">      page.render(renderContext).then(() =&gt; &#123;</span><br><span class="line">        pageNumber += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (pageNumber &lt;= numPages) &#123;</span><br><span class="line">          _this.getPage(pdf, pageNumber, numPages)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、效果"><a href="#3、效果" class="headerlink" title="3、效果"></a>3、效果</h2><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/vue-pdfjs-demo.png" alt="Alt"><br></div><h2 id="4、注意点"><a href="#4、注意点" class="headerlink" title="4、注意点"></a>4、注意点</h2><p>当PDF文件中有中文的情况下，在引用pdfjs过程中可能会出现中文不显示问题，在console中会报下面的错误，<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Warning</span>: The CMap <span class="string">"baseUrl"</span> <span class="keyword">parameter</span> must be specified, ensure that the <span class="string">"cMapUrl"</span> <span class="keyword">and</span> <span class="string">"cMapPacked"</span> API parameters are provided.</span><br></pre></td></tr></table></figure></p><p>主要原因是有pdf不支持的字体格式，可以通过引入pdf.js的字体来解决该问题。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入pdf.js的字体</span></span><br><span class="line"><span class="keyword">let</span> CMAP_URL = <span class="string">'https://unpkg.com/pdfjs-dist@2.0.943/cmaps/'</span></span><br><span class="line"><span class="comment">//读取base64的pdf流文件</span></span><br><span class="line"><span class="keyword">let</span> loadingTask = pdfJS.getDocument(&#123;</span><br><span class="line">  data: <span class="keyword">this</span>.pdfData, <span class="comment">// PDF base64编码</span></span><br><span class="line">  cMapUrl: CMAP_URL,</span><br><span class="line">  cMapPacked: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>完整代码获取：</strong><br><a href="https://github.com/HamptonChen/hampton-demo-repo/tree/master/example-project" target="_blank" rel="noopener">https://github.com/HamptonChen/hampton-demo-repo/tree/master/example-project</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;现在很多项目开发过程中都会碰到PDF在线预览的需求，对于PC端浏览器，一般直接提供PDF文件，iframe一下就可以直接预览。但在移动端要预
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="pdf.js" scheme="http://www.chenhanpeng.com/tags/pdf-js/"/>
    
      <category term="在线预览PDF文件" scheme="http://www.chenhanpeng.com/tags/%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88PDF%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>利用TensorFlow Object Detection API实现图片和视频物体检测</title>
    <link href="http://www.chenhanpeng.com/2019/06/21/%E5%88%A9%E7%94%A8TensorFlow%20Object%20Detection%20API%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%92%8C%E8%A7%86%E9%A2%91%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B/"/>
    <id>http://www.chenhanpeng.com/2019/06/21/利用TensorFlow Object Detection API实现图片和视频物体检测/</id>
    <published>2019-06-21T15:50:14.000Z</published>
    <updated>2019-06-21T15:58:57.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TensorFlow-Object-Detection-API介绍"><a href="#TensorFlow-Object-Detection-API介绍" class="headerlink" title="TensorFlow Object Detection API介绍"></a>TensorFlow Object Detection API介绍</h1><p>物体检测是检测图片或视频中所出现的全部物体，并用矩形进行标注，物体的类别可以包括多种，比如：人、车、动物等等，即正确的答案可以是多个。</p><p>TensorFlow提供了用于检测图片或视频中所包含物体的接口(Object Detection API)，具体详情可参考下面链接：<br><a href="https://github.com/tensorflow/models/tree/master/research/object_detection" target="_blank" rel="noopener">https://github.com/tensorflow/models/tree/master/research/object_detection</a></p><p>这个API是用COCO数据集 (<a href="http://cocodataset.org/#home" target="_blank" rel="noopener">http://cocodataset.org/#home</a>) 训练出来的，是一个大型的、丰富的物体检测，分割和字幕数据集,大约有30万张图像、90种最常见物体。</p><p>这个API提供了多种不同的，使用者可以通过设置不同检测边界范围来平衡运行速度和准确率。</p><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/TensorFlow/tensorflow-object-detection-1.png" alt="Alt"><br></div><p>图中的mAP（平均精度）是检测边界框的准确率和召回率的乘积。这是一个很好的混合测度，在评价模型对目标物体的敏锐度和它是否能很好避免虚假目标中非常好用。mAP值越高，模型的准确度越高，但运行速度会相应下降。</p><h1 id="实现物体检测"><a href="#实现物体检测" class="headerlink" title="实现物体检测"></a>实现物体检测</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本文代码运行环境：Python3.6、jupyter notebook</p><p>首先安装相关依赖包<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install </span><span class="keyword">jupyter</span></span><br><span class="line"><span class="keyword">pip </span><span class="keyword">install </span>tensorflow</span><br><span class="line">pip <span class="keyword">install </span>pillow  </span><br><span class="line">pip <span class="keyword">install </span>lxml</span><br><span class="line">pip <span class="keyword">install </span>matplotlib</span><br><span class="line">pip <span class="keyword">install </span>numpy</span><br><span class="line">pip <span class="keyword">install </span>opencv-python</span><br></pre></td></tr></table></figure></p><h2 id="图片物体检测"><a href="#图片物体检测" class="headerlink" title="图片物体检测:"></a>图片物体检测:</h2><h3 id="1、加载库"><a href="#1、加载库" class="headerlink" title="1、加载库"></a>1、加载库</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="title">from</span> <span class="type">PIL</span> <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure><h3 id="2、从utils模块引入label-map-util和visualization-utils"><a href="#2、从utils模块引入label-map-util和visualization-utils" class="headerlink" title="2、从utils模块引入label_map_util和visualization_utils"></a>2、从utils模块引入label_map_util和visualization_utils</h3><p>label_map_util用于后面获取图像标签和类别，visualization_utils用于可视化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> label_map_util</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> vis_util</span><br></pre></td></tr></table></figure></p><h3 id="3、加载预训练好的模型"><a href="#3、加载预训练好的模型" class="headerlink" title="3、加载预训练好的模型"></a>3、加载预训练好的模型</h3><p>模型下载地址：<br><a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md" target="_blank" rel="noopener">https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md</a><br>这里我们选用最轻量级的模型(ssd_mobilenet_v1_coco)。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PATH_TO_CKPT = <span class="string">'ssd_mobilenet_v1_coco_2018_01_28/frozen_inference_graph.pb'</span></span><br><span class="line">PATH_TO_LABELS = <span class="string">'data/mscoco_label_map.pbtxt'</span></span><br><span class="line">NUM_CLASSES = <span class="number">90</span></span><br><span class="line"></span><br><span class="line">detection_graph = <span class="keyword">tf</span>.Graph()</span><br><span class="line"></span><br><span class="line">with detection_graph.as_default():</span><br><span class="line">    od_graph_def = <span class="keyword">tf</span>.GraphDef()</span><br><span class="line">    with <span class="keyword">tf</span>.gfile.GFile(PATH_TO_CKPT, <span class="string">'rb'</span>) <span class="keyword">as</span> fid:</span><br><span class="line">        od_graph_def.ParseFromString(fid.<span class="keyword">read</span>())</span><br><span class="line">        <span class="keyword">tf</span>.import_graph_def(od_graph_def, name=<span class="string">''</span>)</span><br></pre></td></tr></table></figure></p><h3 id="4、加载分类标签数据"><a href="#4、加载分类标签数据" class="headerlink" title="4、加载分类标签数据"></a>4、加载分类标签数据</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">label_map</span> = label_map_util.load_labelmap(PATH_TO_LABELS)</span><br><span class="line"><span class="attr">categories</span> = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=<span class="literal">True</span>)</span><br><span class="line"><span class="attr">category_index</span> = label_map_util.create_category_index(categories)</span><br></pre></td></tr></table></figure><h3 id="5、核心代码：一个将图片转为数组的辅助函数，以及测试图片路径，使用模型进行物体检测："><a href="#5、核心代码：一个将图片转为数组的辅助函数，以及测试图片路径，使用模型进行物体检测：" class="headerlink" title="5、核心代码：一个将图片转为数组的辅助函数，以及测试图片路径，使用模型进行物体检测："></a>5、核心代码：一个将图片转为数组的辅助函数，以及测试图片路径，使用模型进行物体检测：</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def load_image_into_numpy_array(<span class="built_in">image</span>):</span><br><span class="line">    (im_width, im_height) = <span class="built_in">image</span>.size</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">np</span>.<span class="built_in">array</span>(<span class="built_in">image</span>.getdata()).reshape((im_height, im_width, <span class="number">3</span>)).astype(<span class="built_in">np</span>.uint8)</span><br><span class="line"></span><br><span class="line">TEST_IMAGE_PATHS = ['test_data/image1.jpg']</span><br><span class="line"></span><br><span class="line">with detection_graph.as_default():</span><br><span class="line">    with tf.Session(graph=detection_graph) as sess:</span><br><span class="line">        image_tensor = detection_graph.get_tensor_by_name('image_tensor:<span class="number">0</span>')</span><br><span class="line">        detection_boxes = detection_graph.get_tensor_by_name('detection_boxes:<span class="number">0</span>')</span><br><span class="line">        detection_scores = detection_graph.get_tensor_by_name('detection_scores:<span class="number">0</span>')</span><br><span class="line">        detection_classes = detection_graph.get_tensor_by_name('detection_classes:<span class="number">0</span>')</span><br><span class="line">        num_detections = detection_graph.get_tensor_by_name('num_detections:<span class="number">0</span>')</span><br><span class="line">        <span class="keyword">for</span> image_path <span class="keyword">in</span> TEST_IMAGE_PATHS:</span><br><span class="line">            <span class="built_in">image</span> = Image.open(image_path)</span><br><span class="line">            image_np = load_image_into_numpy_array(<span class="built_in">image</span>)</span><br><span class="line">            image_np_expanded = <span class="built_in">np</span>.expand_dims(image_np, axis=<span class="number">0</span>)</span><br><span class="line">            (boxes, scores, classes, <span class="built_in">num</span>) = sess.run(</span><br><span class="line">                [detection_boxes, detection_scores, detection_classes, num_detections], </span><br><span class="line">                feed_dict=&#123;image_tensor: image_np_expanded&#125;)</span><br><span class="line">            vis_util.visualize_boxes_and_labels_on_image_array(image_np, <span class="built_in">np</span>.squeeze(boxes), <span class="built_in">np</span>.squeeze(classes).astype(<span class="built_in">np</span>.int32), <span class="built_in">np</span>.squeeze(scores), category_index, use_normalized_coordinates=True, line_thickness=<span class="number">8</span>)</span><br><span class="line">            plt.figure(figsize=[<span class="number">12</span>, <span class="number">8</span>])</span><br><span class="line">            plt.imshow(image_np)</span><br><span class="line">            plt.<span class="built_in">show</span>()</span><br></pre></td></tr></table></figure><h3 id="检测结果如下："><a href="#检测结果如下：" class="headerlink" title="检测结果如下："></a>检测结果如下：</h3><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/TensorFlow/output_image1.png" alt="Alt"><br></div><h2 id="视频物体检测"><a href="#视频物体检测" class="headerlink" title="视频物体检测"></a>视频物体检测</h2><p>使用cv2读取视频并获取每一帧图片，然后将检测后的每一帧写入新的视频文件。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> numpy as np</span><br><span class="line"><span class="built_in">import</span> tensorflow as tf</span><br><span class="line"><span class="built_in">import</span> cv2</span><br><span class="line"></span><br><span class="line">from utils <span class="built_in">import</span> label_map_util</span><br><span class="line">from utils <span class="built_in">import</span> visualization_utils as vis_util</span><br><span class="line"></span><br><span class="line"><span class="attr">cap</span> = cv2.VideoCapture('test_data/test_video.mp4')</span><br><span class="line">ret, <span class="attr">image_np</span> = cap.read()</span><br><span class="line"><span class="attr">out</span> = cv2.VideoWriter('output_video.mp4', -<span class="number">1</span>, cap.get(cv2.CAP_PROP_FPS), (image_np.shape[<span class="number">1</span>], image_np.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="attr">PATH_TO_CKPT</span> = 'ssd_mobilenet_v1_coco_2018_01_28/frozen_inference_graph.pb'</span><br><span class="line"><span class="attr">PATH_TO_LABELS</span> = 'data/mscoco_label_map.pbtxt'</span><br><span class="line"><span class="attr">NUM_CLASSES</span> = <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="attr">detection_graph</span> = tf.Graph()</span><br><span class="line"><span class="keyword">with</span> detection_graph.as_default():</span><br><span class="line">    <span class="attr">od_graph_def</span> = tf.GraphDef()</span><br><span class="line">    <span class="keyword">with</span> tf.gfile.GFile(PATH_TO_CKPT, 'rb') as fid:</span><br><span class="line">        od_graph_def.ParseFromString(fid.read())</span><br><span class="line">        tf.import_graph_def(od_graph_def, <span class="attr">name='')</span></span><br><span class="line">        </span><br><span class="line"><span class="attr">label_map</span> = label_map_util.load_labelmap(PATH_TO_LABELS)</span><br><span class="line"><span class="attr">categories</span> = label_map_util.convert_label_map_to_categories(label_map, <span class="attr">max_num_classes=NUM_CLASSES,</span> <span class="attr">use_display_name=True)</span></span><br><span class="line"><span class="attr">category_index</span> = label_map_util.create_category_index(categories)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> detection_graph.as_default():</span><br><span class="line">    <span class="keyword">with</span> tf.Session(<span class="attr">graph=detection_graph)</span> as sess:</span><br><span class="line">        <span class="attr">image_tensor</span> = detection_graph.get_tensor_by_name('image_tensor:<span class="number">0</span>')</span><br><span class="line">        <span class="attr">detection_boxes</span> = detection_graph.get_tensor_by_name('detection_boxes:<span class="number">0</span>')</span><br><span class="line">        <span class="attr">detection_scores</span> = detection_graph.get_tensor_by_name('detection_scores:<span class="number">0</span>')</span><br><span class="line">        <span class="attr">detection_classes</span> = detection_graph.get_tensor_by_name('detection_classes:<span class="number">0</span>')</span><br><span class="line">        <span class="attr">num_detections</span> = detection_graph.get_tensor_by_name('num_detections:<span class="number">0</span>')</span><br><span class="line">        while cap.isOpened():</span><br><span class="line">            ret, <span class="attr">image_np</span> = cap.read()</span><br><span class="line">            <span class="keyword">if</span> len((np.array(image_np)).shape) == <span class="number">0</span>:</span><br><span class="line">                break</span><br><span class="line">            </span><br><span class="line">            <span class="attr">image_np</span> = cv2.cvtColor(image_np, cv2.COLOR_BGR2RGB)</span><br><span class="line">            <span class="attr">image_np_expanded</span> = np.expand_dims(image_np, <span class="attr">axis=0)</span></span><br><span class="line">            </span><br><span class="line">            (boxes, scores, classes, num) = sess.run([detection_boxes, detection_scores, detection_classes, num_detections], <span class="attr">feed_dict=&#123;image_tensor:</span> image_np_expanded&#125;)</span><br><span class="line">            </span><br><span class="line">            vis_util.visualize_boxes_and_labels_on_image_array(image_np, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), category_index, <span class="attr">use_normalized_coordinates=True,</span> <span class="attr">line_thickness=8)</span></span><br><span class="line">            out.write(cv2.cvtColor(image_np, cv2.COLOR_RGB2BGR))</span><br><span class="line">            </span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="检测效果"><a href="#检测效果" class="headerlink" title="检测效果"></a>检测效果</h3><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/TensorFlow/video_output_image.png" alt="Alt"><br></div><p>至此我们利用tensorflow提供的物体检测API，实现了图片和视频的物体检测。</p><p>完整的代码和检测后的视频，请至github查看：<br><a href="https://github.com/HamptonChen/tensorflow-learning" target="_blank" rel="noopener">https://github.com/HamptonChen/tensorflow-learning</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TensorFlow-Object-Detection-API介绍&quot;&gt;&lt;a href=&quot;#TensorFlow-Object-Detection-API介绍&quot; class=&quot;headerlink&quot; title=&quot;TensorFlow Object Detectio
      
    
    </summary>
    
      <category term="机器学习" scheme="http://www.chenhanpeng.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="TensorFlow" scheme="http://www.chenhanpeng.com/tags/TensorFlow/"/>
    
      <category term="物体检测" scheme="http://www.chenhanpeng.com/tags/%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow基础概念</title>
    <link href="http://www.chenhanpeng.com/2019/06/11/TensorFlow%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.chenhanpeng.com/2019/06/11/TensorFlow基础概念/</id>
    <published>2019-06-11T15:25:14.000Z</published>
    <updated>2019-06-11T15:29:26.714Z</updated>
    
    <content type="html"><![CDATA[<p>TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。</p><p>TensorFlow 是Google第二代大规模分布式深度学习框架。</p><ul><li>灵活通用的深度学习库</li><li>端云结合的人工智能引擎</li><li>高性能的基础平台软件</li><li>跨平台的机器学习系统</li></ul><p><strong>应用场景：</strong></p><p>行人检测、人脸检测、行为识别、身份证自动输入与人脸图像比较、OCR+自动化审核</p><h2 id="TensorFlow-数据流图介绍"><a href="#TensorFlow-数据流图介绍" class="headerlink" title="TensorFlow 数据流图介绍"></a>TensorFlow 数据流图介绍</h2><p>TensorFlow数据流图是一种声明式编程范式</p><p>声明式编程与命令式编程的多角度对比</p><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/TensorFlow/tensorflow-base-liutu-1.png" alt="Alt"><br></div><p>数据流图由有向边和节点组成</p><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/TensorFlow/tensorflow-base-liutu-2.png" alt="Alt"><br></div><p>数据流图的优势：<strong>快</strong></p><ul><li>并行计算快</li><li>分布式计算快(CPUs,GPUs,TPUs)</li><li>预编译优化(XLA)</li><li>可移植性好(Language-independent representation)</li></ul><h2 id="张量-Tensor"><a href="#张量-Tensor" class="headerlink" title="张量(Tensor)"></a>张量(Tensor)</h2><p>在数学里，张量是一种几何实体，广义上表示任意形式的“数据”。张量可以理解为0阶（rank）标量、1阶向量和2阶矩阵在高维度空间上的推广，张量的阶描述它表示数据的最大维度。</p><p>在TensorFlow中，张量表示某种相同的数据类型的多维数组<br>因此，张量有两个重要的属性：</p><p>1、<strong>数据类型</strong>，如浮点型、整型、字符串</p><p>2、<strong>数组形状</strong>： 各个维度的大小</p><p>TensorFlow张量是什么可以总结为一下几点：</p><ul><li>张量是用来表示多维数据的</li><li>张量是执行操作时的输入或输出数据</li><li>用户通过执行操作来创建或计算张量</li><li>张量的形状不一定在编译时确定，可以在运行时通过形状推断计算得到</li></ul><p>几类比较特别的张量，由以下操作产生：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tf<span class="selector-class">.constant</span>     <span class="comment">// 常量</span></span><br><span class="line">tf<span class="selector-class">.placeholder</span>   <span class="comment">// 占位符</span></span><br><span class="line">tf<span class="selector-class">.Variable</span>      <span class="comment">// 变量</span></span><br></pre></td></tr></table></figure></p><h2 id="变量-Variable"><a href="#变量-Variable" class="headerlink" title="变量(Variable)"></a>变量(Variable)</h2><p>变量Variable是一种特殊的张量，主要作用是维护特定节点的状态，如深度学习或机器学习的模型参数。</p><p>tf.Variable方法是操作，返回值是变量（特殊张量）</p><p>通过tf.Variable方法创建的变量，与张量一样，可以作为操作的输入和输出。</p><p>不同之处：</p><ul><li>张量的生命周期通常随依赖的计算完成而结束，内存也随即释放</li><li>变量则常驻内存，在每一步训练时不断更新值，以实现模型参数的更新。</li></ul><h3 id="TensorFlow变量使用流程"><a href="#TensorFlow变量使用流程" class="headerlink" title="TensorFlow变量使用流程"></a>TensorFlow变量使用流程</h3><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/TensorFlow/tensorflow-base-variable-1.png" alt="Alt"><br></div><h2 id="操作-Operation"><a href="#操作-Operation" class="headerlink" title="操作(Operation)"></a>操作(Operation)</h2><p>TensorFlow用数据流图表示算法模型。数据流图由节点和有向边组成，每个节点均对应一个具体的操作。因此，操作是模型功能的<strong>实际载体</strong>。</p><p>数据流图中的节点按照功能不同可以分为3种：</p><ul><li><strong>存储节点</strong>：有状态的变量操作，通常用来存储模型参数</li><li><strong>计算节点</strong>：无状态的计算或控制操作，主要负责算法逻辑表达或流程控制。</li><li><strong>数据节点</strong>：数据的占位符操作，用于描述图外输入数据的属性。</li></ul><p><strong>操作的输入和输出是张量或操作（函数式编程）</strong></p><h3 id="TensorFlow典型计算和控制操作"><a href="#TensorFlow典型计算和控制操作" class="headerlink" title="TensorFlow典型计算和控制操作"></a>TensorFlow典型计算和控制操作</h3><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/TensorFlow/tensorflow-base-operation-1.png" alt="Alt"><br></div><h3 id="TensorFlow占位符操作"><a href="#TensorFlow占位符操作" class="headerlink" title="TensorFlow占位符操作"></a>TensorFlow占位符操作</h3><p>tensorflow 使用占位符操作表示图外输入的数据，如训练数据和测试数据。</p><p>TensorFlow数据流图描述了算法模型的计算拓扑，其中的各个操作(节点)都是抽象的函数映射或数学表达式。</p><p>换句话说，数据流图本身是一个具有计算拓扑和内部结构的“壳”。在用户向数据流图填充数据前，图中并没有真正执行任何计算。</p><h2 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话(Session)"></a>会话(Session)</h2><p>会话提供了估算张量和执行操作的运行环境，它是发放计算任务的客户端，所有计算任务都由它连接的执行引擎完成。一个会话的典型使用流程分为以下3步：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、创建会话</span></span><br><span class="line"><span class="comment"># target:会话连接的执行引擎  graph:会话加载的数据流图  config:会话启动时的配置项</span></span><br><span class="line">sess = tf.Session(<span class="attribute">target</span>=..., <span class="attribute">graph</span>=..., <span class="attribute">config</span>=...)</span><br><span class="line"><span class="comment"># 2、估算张量或执行操作</span></span><br><span class="line">sess.<span class="builtin-name">run</span>(<span class="built_in">..</span>.)</span><br><span class="line"><span class="comment"># 3、关闭会话</span></span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure></p><h3 id="会话执行"><a href="#会话执行" class="headerlink" title="会话执行"></a>会话执行</h3><p>获取张量值的另外两种方法：估算张量(Tensor.eval)与执行操作(Operation.run)</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow <span class="keyword">as</span> <span class="keyword">tf</span></span><br><span class="line"># 创建数据流图：<span class="keyword">y</span>=<span class="keyword">w</span> * <span class="keyword">x</span> + <span class="keyword">b</span>, 其中<span class="keyword">w</span>和<span class="keyword">b</span>为存储节点，<span class="keyword">x</span>为数据节点</span><br><span class="line"><span class="keyword">x</span> = <span class="keyword">tf</span>.placeholder(<span class="keyword">tf</span>.float32)</span><br><span class="line"><span class="keyword">w</span> = <span class="keyword">tf</span>.Variable(<span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">b</span> = <span class="keyword">tf</span>.Variable(<span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">y</span> = <span class="keyword">w</span> * <span class="keyword">x</span> + <span class="keyword">b</span></span><br><span class="line">with <span class="keyword">tf</span>.Session() <span class="keyword">as</span> ses<span class="variable">s:</span></span><br><span class="line">    <span class="keyword">tf</span>.global_variables_initializer().run() # Operation.run</span><br><span class="line">    fetch = <span class="keyword">y</span>.<span class="built_in">eval</span>(feed_dict=&#123;<span class="keyword">x</span>: <span class="number">3.0</span>&#125;) # Tensor.<span class="built_in">eval</span></span><br><span class="line">    <span class="keyword">print</span>(fetch)   # fetch = <span class="number">1.0</span> * <span class="number">3.0</span> + <span class="number">1.0</span></span><br></pre></td></tr></table></figure><h3 id="会话执行原理"><a href="#会话执行原理" class="headerlink" title="会话执行原理"></a>会话执行原理</h3><p>当我们调用sess.run(train_op)语句执行训练操作时：</p><ul><li>首先，程序内部提取操作依赖的所有前置操作。这些操作的节点共同组成一幅子图。</li><li>然后，程序会将子图中的计算节点、存储节点和数据节点按照各自的执行设备分类，相同设备上的节点组成了一幅局部图</li><li>最后，每个设备上的局部图在实际执行时，根据节点间的依赖关系将各个节点有序地加载到设备上执行。</li></ul><h2 id="优化器-Optimizer"><a href="#优化器-Optimizer" class="headerlink" title="优化器(Optimizer)"></a>优化器(Optimizer)</h2><p>优化器是实现优化算法的载体。</p><p>一次典型的迭代优化应该分为以下3个步骤：</p><p>1、<strong>计算梯度</strong>：调用compute_gradients方法;</p><p>2、<strong>处理梯度</strong>：用户按照自己需求处理梯度值，如梯度裁剪和梯度加权等。</p><p>3、<strong>应用梯度</strong>：调用apply_gradients方法，将处理后的梯度值应用到模型参数。</p><p>TensorFlow内置优化器：</p><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/TensorFlow/tensorflow-base-optimizer.png" alt="Alt"><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。&lt;/p&gt;
&lt;p&gt;TensorFlow 是Google第二代大规模分布式深度学习框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;灵活通用的深度学习库&lt;/li&gt;
&lt;li&gt;端云结合的人工智能引
      
    
    </summary>
    
      <category term="机器学习" scheme="http://www.chenhanpeng.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="TensorFlow" scheme="http://www.chenhanpeng.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>CF-基于协同过滤的推荐算法</title>
    <link href="http://www.chenhanpeng.com/2019/05/13/CF-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    <id>http://www.chenhanpeng.com/2019/05/13/CF-基于协同过滤的推荐算法/</id>
    <published>2019-05-13T15:05:11.000Z</published>
    <updated>2019-06-12T01:20:54.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>上一篇文章我们介绍了CB推荐算法，本篇文章我们将介绍另外一种推荐算法——基于协同过滤的推荐算法(Collaborative Filtering Recommendations)，下文我们统一简称为CF算法。</p><p>协同过滤推荐算法作为推荐算法中最经典的类型，包括在线的协同和离线的过滤两部分。在线协同是指通过在线数据找到用户可能喜欢的物品，离线过滤则是过滤掉一些不值得推荐的数据，比如推荐评分低的，或者推荐评分高但用户已经购买过的数据。</p><p>CF算法的数据源是基于用户历史行为和物品的矩阵数据，即UI（User-Item）矩阵数据。CF算法一般可以分为基于用户（User-Based）的协同过滤和基于物品（item-based）的协同过滤。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><h2 id="1、-User-Based-CF"><a href="#1、-User-Based-CF" class="headerlink" title="1、 User-Based CF"></a>1、 User-Based CF</h2><p>假设：</p><ul><li>用户喜欢跟他过去喜欢的物品相似的物品</li><li>历史上相似的物品在未来也相似</li></ul><p>方法：</p><ul><li>给定用户u，找到他过去喜欢的物品的集合R(u)</li><li>把和R(u)相似的物品推荐给u</li></ul><h2 id="2、-Item-Based-CF"><a href="#2、-Item-Based-CF" class="headerlink" title="2、 Item-Based CF"></a>2、 Item-Based CF</h2><p>假设：</p><ul><li>用户喜欢跟他过去喜欢的物品相似的物品</li><li>历史上相似的物品在未来也相似</li></ul><p>方法：</p><ul><li>给定用户u，找到他过去喜欢的物品的集合R(u)</li><li>把和R(u)相似的物品推荐给u</li></ul><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/CF_1.png" alt="Alt"><br></div><h1 id="CF算法优缺点"><a href="#CF算法优缺点" class="headerlink" title="CF算法优缺点"></a>CF算法优缺点</h1><p><strong>优点：</strong></p><ul><li>充分利用群体智慧</li><li>推荐精度高于CB</li><li>利于挖掘隐含的相关性</li></ul><p><strong>缺点：</strong></p><ul><li>推荐结果解释性较差</li><li>对时效性强的Item不适用</li><li>冷启动问题</li></ul><h1 id="算法处理过程"><a href="#算法处理过程" class="headerlink" title="算法处理过程"></a>算法处理过程</h1><h3 id="1、数据准备"><a href="#1、数据准备" class="headerlink" title="1、数据准备"></a>1、数据准备</h3><p>用户user_id,物品item_id，打分score（score可以是用户对某件物品的评分，或是根据用户行为计算出的偏好度得分，比如曝光、点击、收藏的加权得分，具体权重可以参考漏斗模型），数据如下：</p><table><thead><tr><th>user_id</th><th>item_id</th><th>score</th></tr></thead><tbody><tr><td>id1</td><td>item1</td><td>3</td></tr><tr><td>id1</td><td>item2</td><td>2</td></tr><tr><td>id2</td><td>item1</td><td>4</td></tr><tr><td>id2</td><td>item2</td><td>3</td></tr></tbody></table><h3 id="2、计算相似性矩阵"><a href="#2、计算相似性矩阵" class="headerlink" title="2、计算相似性矩阵"></a>2、计算相似性矩阵</h3><p>CF算法的关键在于计算获得user或item的相似度矩阵，即UU矩阵和II矩阵。</p><p><strong>User-Based：</strong></p><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/CF_2.png" alt="Alt"><br></div><p>用户之间的相似度计算，是基于对相同的物品打过分，可以将各个分值联合起来作为一个向量，然后计算余弦相似度：</p><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/CF_3.jpg" alt="Alt"><br></div><p><strong>Item-Based：</strong></p><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/CF_5.png" alt="Alt"><br></div><p>计算各个Item之间的相似度矩阵，即对两个Item都打过分的id的打分情况作为向量，同理得到item的相似度矩阵。</p><h3 id="3、推荐"><a href="#3、推荐" class="headerlink" title="3、推荐"></a>3、推荐</h3><p>根据相似度矩阵，选择与目标用户相似度最高的几位用户，在第一张表中选取各自打分较高的物品，形成一个推荐候选集合，准备推荐给目标用户。</p><h1 id="User-Based-CF和Item-Based-CF区别"><a href="#User-Based-CF和Item-Based-CF区别" class="headerlink" title="User-Based CF和Item-Based CF区别"></a>User-Based CF和Item-Based CF区别</h1><p>通过两种方法，我们发现两种的分数不一样，那么该用哪个呢，哪个真实，其实这个不重要，生活中我们一般是基于用户给用户推荐Top问题，而不是打分情况，即只要排好序就可以，工作这个分数其实还是有用的，一般我们有这么个准则，哪个维度小用哪个，电商网站物品的矩阵远大于用户矩阵，规模太大有时候造成一些慢，相反一样 </p><p>那么我们来看一下这两个对比不同</p><table><thead><tr><th></th><th>User-Based</th><th>Item-Based</th></tr></thead><tbody><tr><td>性能</td><td>适用用户较少场合，如果用户多，计算用户相似矩阵代价太大</td><td>适用于物品数明显小于用户数的场合，如果物品很多，计算物品相似度矩阵代价很大</td></tr><tr><td>领域</td><td>时效性强，用户个性化兴趣不太明显的领域</td><td>长尾物品丰富，用户个性化需求强烈的领域</td></tr><tr><td>实时性</td><td>用户有新行为，不一定造成推荐结果立即变化</td><td>用户有新行为，一定会导致推荐结果的实时变化</td></tr><tr><td>冷启动</td><td>在新用户对很少的物品产生行为后，不能立即对他进行个性化推荐，因为用户相似度表是每隔一段时间离线计算的  新物品上线后一段时间，一旦有用户对物品产生行为，就可以将新物品推荐给对它产生行为的用户兴趣相似的其他用户</td><td>新用户只要对一个物品产生行为，就可以给他推荐和该物品相关的其他物品   但没有办法在不离线更新物品相似度表的情况下将新物品推荐给用户</td></tr><tr><td>推荐理由</td><td>很难提供令用户信服的推荐解释</td><td>利用用户的历史行为给用户做推荐解释，可以令用户比较信服</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;上一篇文章我们介绍了CB推荐算法，本篇文章我们将介绍另外一种推荐算法——基于协同过滤的推荐算法(Collaborative Filterin
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.chenhanpeng.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="推荐算法" scheme="http://www.chenhanpeng.com/tags/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    
      <category term="大数据" scheme="http://www.chenhanpeng.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>CB-基于内容的推荐算法</title>
    <link href="http://www.chenhanpeng.com/2019/05/07/CB-%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    <id>http://www.chenhanpeng.com/2019/05/07/CB-基于内容的推荐算法/</id>
    <published>2019-05-07T15:57:25.000Z</published>
    <updated>2019-06-12T01:20:57.186Z</updated>
    
    <content type="html"><![CDATA[<p>在推荐系统领域，一般主要有两种推荐任务：评分预测和Top-N推荐。下面我们简单介绍一下这两种推荐任务：</p><h3 id="评分预测："><a href="#评分预测：" class="headerlink" title="评分预测："></a>评分预测：</h3><p>我们以音乐推荐系统为例，首先用户A和用户B都对某几首歌进行喜欢程度打分，假设两个用户对周杰伦的《稻香》和陈奕迅的《好久不见》有相同的喜欢程度，且打分都不低，那么我们是否可以预测这两个用户有相同的爱好，那么我们可以将用户A喜欢的《青花瓷》这首歌推荐给用户B。</p><h3 id="Top-N推荐"><a href="#Top-N推荐" class="headerlink" title="Top-N推荐"></a>Top-N推荐</h3><p>假设用户A喜欢的音乐列表里有《十年》、《好久不见》、《稻香》，用户B喜欢的音乐列表里有《同桌的你》、《三国杀》、《逆战》，假设用户C刚开始使用该系统，并将《稻香》添加到喜欢的音乐中，那么我们是不是可以先推荐与用户C喜好相近的用户A喜欢的音乐给用户C，再推荐用户B喜欢的音乐。先推荐关联性高的，将关联性低的放在后面，这就是Top-N推荐。</p><h1 id="基于内容的推荐算法-CB"><a href="#基于内容的推荐算法-CB" class="headerlink" title="基于内容的推荐算法(CB)"></a>基于内容的推荐算法(CB)</h1><p>今天要介绍的CB(Content-Based Recommendations)算法是众多推荐推荐算法中的一种，也是比较早被使用的一种推荐算法。</p><h2 id="1、引入Item属性的基于内容的推荐"><a href="#1、引入Item属性的基于内容的推荐" class="headerlink" title="1、引入Item属性的基于内容的推荐"></a>1、引入Item属性的基于内容的推荐</h2><p>用户喜欢歌曲A(item)，现在有一首新歌曲B，如何确定是否要推荐给用户？</p><ul><li><p>首先我们对所有的音乐进行内容分析和item内容属性索引，即进行特征建立和建模，音乐的特征有：作者、年代、音乐风格等等。</p></li><li><p>然后我们去计算歌曲A和歌曲B两者的相关性，如何相关性高，则将歌曲B推荐给用户。</p></li></ul><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/CB-item.png" alt="Alt"><br></div><p>这类推荐算法有以下优缺点：</p><p><strong>优点：</strong></p><ul><li>提升推荐结果的相关性</li><li>结果可解释</li><li>推荐结果容易被用户感知</li></ul><p><strong>缺点：</strong></p><ul><li>无个性化</li><li>依赖于对item的深度分析</li></ul><h2 id="2、引入User属性的基于内容的推荐"><a href="#2、引入User属性的基于内容的推荐" class="headerlink" title="2、引入User属性的基于内容的推荐"></a>2、引入User属性的基于内容的推荐</h2><p>引入User属性的基于内容推荐算法加入了用户行为分析和建立用户兴趣模型。假设用户在过去的一段时间里听了爵士乐、DJ、周杰伦的歌，我们可以根据这几个历史标签进行数据建模，建立历史标签的正排倒排的内容分析。与上面不同的是这方面是基于用户的历史行为作分析，我们将其存到数据库，以后为用户推荐音乐时，先查库，然后进行相关的推荐。</p><div style="display: flex; justify-content: center;"><br><img src="/images/articles/2019/CB-user.png" alt="Alt"><br></div><p>这类推荐算法有以下优缺点：</p><p><strong>优点：</strong></p><ul><li>用户模型刻画了用户兴趣需求</li><li>推荐形式多样，具有个性化</li><li>结果可解释</li></ul><p><strong>缺点：</strong></p><ul><li>推荐精度低</li><li>马太效应</li><li>用户行为稀疏导致覆盖率低</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在推荐系统领域，一般主要有两种推荐任务：评分预测和Top-N推荐。下面我们简单介绍一下这两种推荐任务：&lt;/p&gt;
&lt;h3 id=&quot;评分预测：&quot;&gt;&lt;a href=&quot;#评分预测：&quot; class=&quot;headerlink&quot; title=&quot;评分预测：&quot;&gt;&lt;/a&gt;评分预测：&lt;/h3&gt;&lt;p
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.chenhanpeng.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="推荐算法" scheme="http://www.chenhanpeng.com/tags/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    
      <category term="大数据" scheme="http://www.chenhanpeng.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Vue-CLI3 环境变量和模式</title>
    <link href="http://www.chenhanpeng.com/2019/04/29/vue-cli3-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.chenhanpeng.com/2019/04/29/vue-cli3-环境变量和模式/</id>
    <published>2019-04-29T14:46:30.000Z</published>
    <updated>2019-08-27T06:40:29.409Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间工作中用Vue-CLI3构建的Vue工程一些静态资源，比如静态H5页面、图片、图标等等，我们一般放在固定的一些服务器上，链接前缀一般相对固定，但我们打包发布一般要区分测试环境和生产环境，此时的静态资源路径也需要区分测试和生产，如果每次打包都要根据部署的环境去修改路径十分麻烦，这时候vue-cli的模式和环境变量则能够很好地解决这个麻烦。</p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p><strong>模式</strong>是Vue CLI项目中一个重要的概念。默认情况下，一个Vue CLI项目有三个模式：</p><ul><li><p>development 模式用于vue-cli-service serve</p></li><li><p>production 模式用于vue-cli-service build和vue-cli-service test:e2e</p></li><li><p>test 模式用于vue-cli-service test:unit</p></li></ul><p>模式不同于NODE_ENV，一个模式可以包含多个环境变量。每个模式都会将NODE_ENV的值设置为模式的名称，比如：development模式下NODE_ENV的值会被设置为development</p><p>当然，我们也可以通过为.env文件增加后缀来设置某个模式下特有的环境变量。</p><h4 id="示例：test模式"><a href="#示例：test模式" class="headerlink" title="示例：test模式"></a>示例：test模式</h4><p>我们在项目根目录下创建一个名为.env.test和.env的文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">.env</span>文件：</span><br><span class="line">VUE_APP_TITLE=VUE-CLI3-DEMO</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// .env.test文件</span><br><span class="line">NODE_ENV=production</span><br><span class="line">VUE_APP_TITLE=VUE-CLI3-DEMO(test)</span><br></pre></td></tr></table></figure><ul><li><p>vue-cli-service build 会加载可能存在的 .env、.env.production 和 .env.production.local 文件然后构建出生产环境应用；</p></li><li><p>vue-cli-service build –mode test 会在 staging 模式下加载可能存在的 .env、.env.test 和 .env.test.local 文件然后构建出生产环境应用。</p></li></ul><p>这两种情况下，根据 NODE_ENV，构建出的应用都是生产环境应用，但是在 test 版本中，process.env.VUE_APP_TITLE 被覆写成了另一个值。</p><p>我们在vue.config.js文件中添加console.log(process.env.VUE_APP_TITLE)</p><p>在package.json文件中添加”build-test”: “vue-cli-service build –mode test”</p><p>执行npm run build和npm run build-test</p><p>通过查看控制台打印出的分别是VUE-CLI3-DEMO和VUE-CLI3-DEMO(test)，由此可见不同模式下的环境变量不同。</p><hr><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>只有以<strong>VUE_APP_</strong>开头的变量才会被webpack.DefinePlugin静态嵌入到客户端侧的包中，我们可以在代码中以下面的方式访问：process.env.VUE_APP_TITLE</p><p>除了VUE_APP_*变量外，还有两个始终可用的特殊变量：</p><ul><li><strong>NODE_ENV</strong>  值为development、productin、test中的一个。</li><li><strong>BASE_URL</strong>  与vue.config.js中的publicPath相符，即应用部署的基础路径</li></ul><hr><p>回到我们最开始的关于静态资源在不同环境下的路径问题，我们可以分别创建.env.test和.env.production两个文件，在文件中添加变量VUE_APP_STATIC_BASE_URL，根据不同环境赋予不同的值，在代码中用到静态资源的时候通过process.env.VUE_APP_STATIC_BASE_URL + 静态资源后续具体路径，再package.json中添加相应的模式打包命令，这样就可以比较好解决我们最开始提出的问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间工作中用Vue-CLI3构建的Vue工程一些静态资源，比如静态H5页面、图片、图标等等，我们一般放在固定的一些服务器上，链接前缀一般相对固定，但我们打包发布一般要区分测试环境和生产环境，此时的静态资源路径也需要区分测试和生产，如果每次打包都要根据部署的环境去修改路径
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue-CLI3" scheme="http://www.chenhanpeng.com/tags/Vue-CLI3/"/>
    
      <category term="模式" scheme="http://www.chenhanpeng.com/tags/%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="环境变量" scheme="http://www.chenhanpeng.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
</feed>
